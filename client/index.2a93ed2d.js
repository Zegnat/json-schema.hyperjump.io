import{S as e,i as n,s as t,e as r,a,d as i,b as s,c as o,f as c,g as l,h as d,j as m,k as u,l as p,m as f,n as h,o as y,t as v,p as g,q as $,r as b,u as w,v as x,w as O,x as I,y as S,z as j,A as K,B as A,C as P,D as E}from"./client.c99458e8.js";var k="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function N(e,n){return e(n={exports:{}},n.exports),n.exports}var R=N(function(e,n){!function(t,r){var a={};t.PubSub=a;var i=t.define;!function(e){var n={},t=-1;function r(e){var n;for(n in e)if(e.hasOwnProperty(n))return!0;return!1}function a(e,n,t){try{e(n,t)}catch(e){setTimeout(function(e){return function(){throw e}}(e),0)}}function i(e,n,t){e(n,t)}function s(e,t,r,s){var o,c=n[t],l=s?i:a;if(n.hasOwnProperty(t))for(o in c)c.hasOwnProperty(o)&&l(c[o],e,r)}function o(e,t,a,i){var o=function(e,n,t){return function(){var r=String(e),a=r.lastIndexOf(".");for(s(e,e,n,t);-1!==a;)r=r.substr(0,a),a=r.lastIndexOf("."),s(e,r,n,t)}}(e="symbol"==typeof e?e.toString():e,t,i),c=function(e){var t=String(e),a=Boolean(n.hasOwnProperty(t)&&r(n[t])),i=t.lastIndexOf(".");for(;!a&&-1!==i;)t=t.substr(0,i),i=t.lastIndexOf("."),a=Boolean(n.hasOwnProperty(t)&&r(n[t]));return a}(e);return!!c&&(!0===a?o():setTimeout(o,0),!0)}e.publish=function(n,t){return o(n,t,!1,e.immediateExceptions)},e.publishSync=function(n,t){return o(n,t,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,n.hasOwnProperty(e)||(n[e]={});var a="uid_"+String(++t);return n[e][a]=r,a},e.subscribeOnce=function(n,t){var r=e.subscribe(n,function(){e.unsubscribe(r),t.apply(this,arguments)});return e},e.clearAllSubscriptions=function(){n={}},e.clearSubscriptions=function(e){var t;for(t in n)n.hasOwnProperty(t)&&0===t.indexOf(e)&&delete n[t]},e.countSubscriptions=function(e){var t,r=0;for(t in n)n.hasOwnProperty(t)&&0===t.indexOf(e)&&r++;return r},e.getSubscriptions=function(e){var t,r=[];for(t in n)n.hasOwnProperty(t)&&0===t.indexOf(e)&&r.push(t);return r},e.unsubscribe=function(t){var r,a,i,s="string"==typeof t&&(n.hasOwnProperty(t)||function(e){var t;for(t in n)if(n.hasOwnProperty(t)&&0===t.indexOf(e))return!0;return!1}(t)),o=!s&&"string"==typeof t,c="function"==typeof t,l=!1;if(!s){for(r in n)if(n.hasOwnProperty(r)){if(a=n[r],o&&a[t]){delete a[t],l=t;break}if(c)for(i in a)a.hasOwnProperty(i)&&a[i]===t&&(delete a[i],l=!0)}return l}e.clearSubscriptions(t)}}(a),"function"==typeof i&&i.amd?i(function(){return a}):(void 0!==e&&e.exports&&(n=e.exports=a),n.PubSub=a,e.exports=n=a)}("object"==typeof window&&window||k)});R.PubSub;var q={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,splitUrl:e=>{const[n,t=""]=e.split("#",2);return[decodeURI(n),decodeURI(t)]}},D=function(e,n){return function t(){null==n&&(n=e.length);var r=[].slice.call(arguments);return r.length>=n?e.apply(this,r):function(){return t.apply(this,r.concat([].slice.call(arguments)))}}};const T=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(F)},M=(e,n,t,r)=>{if(0===e.length)return t;if(e.length>1){const a=e.shift();return{...n,[a]:M(e,U(n,a,r),t,J(a,r))}}if(Array.isArray(n)){const r={...n};return r[e[0]]=t,r}return"object"==typeof n&&null!==n?{...n,[e[0]]:t}:U(n,e[0],r)},L=(e,n,t,r)=>{if(0!==e.length)if(1!==e.length||_(n)){const a=e.shift();L(e,U(n,a,r),t,J(a,r))}else{n[e[0]]=t}},C=(e,n,t)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=U(n,r,t);return{...n,[r]:C(e,a,J(r,t))}}if(Array.isArray(n))return n.filter((n,t)=>t!=e[0]);if("object"==typeof n&&null!==n){const{[e[0]]:t,...r}=n;return r}return U(n,e[0],t)}},V=(e,n,t)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=U(n,r,t);V(e,a,J(r,t))}else Array.isArray(n)?n.splice(e[0],1):"object"==typeof n&&null!==n?delete n[e[0]]:U(n,e[0],t)},J=D((e,n)=>n+"/"+B(e)),B=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),F=e=>e.toString().replace(/~0/g,"~").replace(/~1/g,"/"),U=(e,n,t="")=>{if(_(e))throw Error(`Value at '${t}' is a scalar and can't be indexed`);if(!(n in e))throw Error(`Value at '${t}' does not have index '${n}'`);return e[n]},_=e=>null===e||"object"!=typeof e;var z={nil:"",append:J,get:(e,n)=>{const t=T(e),r=e=>t.reduce(([e,n],t)=>[U(e,t,n),J(t,n)],[e,""])[0];return void 0===n?r:r(n)},set:(e,n,t)=>{const r=T(e),a=D((e,n)=>M(r,e,n,""));return void 0===n?a:a(n,t)},assign:(e,n,t)=>{const r=T(e),a=D((e,n)=>L(r,e,n,""));return void 0===n?a:a(n,t)},unset:(e,n)=>{const t=T(e),r=e=>C(t,e,"");return void 0===n?r:r(n)},delete:(e,n)=>{const t=T(e),r=e=>V(t,e,"");return void 0===n?r:r(n)}};const{splitUrl:G}=q,W=Object.freeze({pointer:"",instance:void 0}),X=(e,n=W)=>Object.freeze({...n,pointer:G(e)[1]}),H=e=>z.get(e.pointer,e.instance),Z=(e,n)=>{const t=z.append(e,n.pointer);return X(`#${encodeURI(t)}`,n)},Q=D((e,n)=>H(n).map((t,r)=>e(Z(r,n),r))),Y=D((e,n,t)=>H(t).reduce((n,r,a)=>e(n,Z(a,t),a),n)),ee=D((e,n)=>Object.keys(H(n)).every((t,r)=>e(Z(t,n),r))),ne=D((e,n)=>Object.keys(H(n)).some((t,r)=>e(Z(t,n),r)));var te={cons:e=>Object.freeze({...W,instance:e}),get:X,uri:e=>`#${encodeURI(e.pointer)}`,value:H,step:Z,entries:e=>Object.keys(H(e)).map(n=>[n,Z(n,e)]),map:Q,reduce:Y,every:ee,some:ne},re=function(e,n){if(e=e.trim(),(n=n.trim()).startsWith("about:"))return n;if(""===e)return oe(n)?ae(n):n;const t=function(e){const n={host:"",path:"",query:"",protocol:""};let t=e,r=e.indexOf("//");if(-1===r)throw new Error("Error, protocol is not specified");n.protocol=t.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),s=e.indexOf("#");-1!==s&&(t=t.substring(0,s));if(-1!==i){const e=t.substring(i);n.query=e,t=t.substring(0,i)}if(-1!==a){const e=t.substring(0,a);n.host=e,t=t.substring(a),n.path=t}else n.host=t;return n}(e);if(""===n){const{host:e,path:n,query:r}=t;return n||r?e+n+r:ae(e)}const r=function(e){const n={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(se.test(e))return n.netPath=!0,n;"/"===e[0]?n.absolutePath=!0:n.relativePath=!0;let t=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=t.substring(a);n.hash=e,t=t.substring(0,a)}if(-1!==r){const e=t.substring(r);n.query=e,t=t.substring(0,r)}return n.path=t,n}(n);if(r.netPath)return r.href.startsWith("//")&&(r.href=t.protocol+r.href),oe(r.href)?ae(r.href):r.href;if(r.absolutePath){const{path:e,query:n,hash:a}=r;return t.host+ie(e)+n+a}if(r.relativePath){const{path:e,query:n,hash:a}=r;let i,s=t.path,o=t.host;return 0===e.length?i=s:(s=s.substring(0,s.lastIndexOf("/")),i=ie(s+"/"+e)),o+=""!==i||n||a?i+n+a:"/"}};function ae(e){return e+("/"===e[e.length-1]?"":"/")}function ie(e){let n=e.split("/");""===n[0]&&(n=n.slice(1));let t=[];return n.forEach((e,r)=>{"."!==e&&(".."===e?t.pop():""===e&&r!==n.length-1||t.push(e))}),"/"+t.join("/")}const se=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");function oe(e){const n=e.indexOf("//")+2,t=!e.includes("/",n),r=!e.includes("?",n),a=!e.includes("#",n);return t&&r&&a}var ce=fetch;const{isObject:le,splitUrl:de}=q,me=Symbol("$__jref"),ue={},pe=(e,n)=>{if(e in ue)return ue[e][n]},fe={},he=(e,n="",t="")=>{const r=de(e.$schema||t)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=pe(r,"idToken"),i=de(n||e[a]||"")[0];if(!i)throw Error("Couldn't determine an identifier for the schema");const s={};fe[i]={schemaVersion:r,schema:ye(e,i,r,z.nil,s),anchors:s,recursiveAnchor:!!e.$recursiveAnchor,validated:!1}},ye=(e,n,t,r,a)=>{if(le(e)){const i=pe(t,"idToken"),s=pe(t,"anchorToken");if("string"==typeof e[i]){const r=e[i],a=be(n,r),[o,c]=de(a);if(delete e[i],c&&(e[s]=s!==i?encodeURI(c):`#${encodeURI(c)}`),o!==n)return he(e,be(n,o),t),{[me]:r}}if("string"==typeof e[s]){const n=s!==i?e[s]:e[s].slice(1);a[n]=r,delete e[s]}return Object.entries(e).reduce((e,[i,s])=>(e[i]=ye(s,n,t,z.append(i,r),a),e),{})}return Array.isArray(e)?e.map((e,i)=>ye(e,n,t,z.append(i,r),a)):e},ve=(e,n)=>{if(!(n in fe[e].anchors))throw Error(`No such anchor '${encodeURI(e)}#${encodeURI(n)}'`);return fe[e].anchors[n]},ge=Object.freeze({id:"http://",schemaVersion:void 0,pointer:"",schema:void 0,recursiveAnchor:!1}),$e=async(e,n=ge,t=!1)=>{const r=t&&n.recursiveAnchor?n.recursiveAnchor:xe(n),a=be(r,e),[i,s]=de(a);if(!(i in fe)){const e=await ce(i);he(await e.json(),i)}const o=Object.freeze({id:i,schemaVersion:fe[i].schemaVersion,pointer:s&&"/"!==s[0]?ve(i,s):s,schema:fe[i].schema,recursiveAnchor:n.recursiveAnchor||!!fe[i].recursiveAnchor&&i,validated:fe[i].validated}),c=Oe(o);return le(c)&&me in c?$e(c[me],o):pe(o.schemaVersion,"jsonReference")&&le(c)&&"string"==typeof c.$ref?$e(c.$ref,o):pe(o.schemaVersion,"keywordReference")&&"string"==typeof c&&o.pointer.endsWith("/$ref")?$e(c,o):pe(o.schemaVersion,"keywordRecursiveReference")&&"string"==typeof c&&o.pointer.endsWith("/$recursiveRef")?$e(c,o,!0):o},be=(e,n)=>{const t=re(e,n);if("file"===we(t)&&"file"!==we(e))throw Error("Can't access file resource from network context");return t},we=e=>{const n=e.match(/(.+):\/\//)[1];return n?n[1]:""},xe=e=>`${e.id}#${encodeURI(e.pointer)}`,Oe=e=>z.get(e.pointer,e.schema),Ie=(e,n)=>{const t=z.append(e,n.pointer);return $e(`#${encodeURI(t)}`,n)},Se=D((e,n)=>Oe(n).map(async(t,r)=>e(await Ie(r,n),r)));var je={setConfig:(e,n,t)=>{ue[e]||(ue[e]={}),ue[e][n]=t},add:he,get:$e,markValidated:e=>{fe[e].validated=!0},uri:xe,value:Oe,step:Ie,sibling:(e,n)=>{const t=n.pointer.split("/");t.pop();const r=z.append(e,t.join("/"));return $e(`#${encodeURI(r)}`,n)},entries:e=>Object.keys(Oe(e)).map(n=>[n,Ie(n,e)]),map:Se};const{isObject:Ke}=q,Ae="FLAG",Pe="BASIC",Ee="DETAILED",ke="VERBOSE";let Ne=Ee;const Re=async(e,n,t)=>{const r={},a=await Fe(e,r),i=(e,n=Ae)=>{if(![Ae,Pe,Ee,ke].includes(n))throw Error(`The '${n}' error format is not supported`);let t=[];const i=R.subscribe("result",qe(n,t));return _e(a,te.cons(e),r),R.unsubscribe(i),t[0]};return void 0===n?i:i(n,t)},qe=(e,n)=>{const t=[];return(r,a)=>{const i={...a,errors:[]};for(;t.length>0&&De(t[t.length-1],i);){const n=t.pop();let r=[];if(e===Pe&&(r=n.errors,delete n.errors),i.errors.unshift(n,...r),Te(i))break}(e===ke||e!==Ae&&!i.valid)&&t.push(i),n[0]=i}},De=(e,n)=>e.instanceLocation.startsWith(n.instanceLocation)&&(e.absoluteKeywordLocation.startsWith(n.absoluteKeywordLocation)||Te(e)),Te=e=>e.keyword.endsWith("#$ref")||e.keyword.endsWith("#$recursiveRef"),Me={},Le=e=>Me[e],Ce=e=>e in Me,Ve=(e,n)=>{Me[e]=n},Je={},Be={},Fe=async(e,n)=>{if(!e.validated){if(!Ce(`${e.schemaVersion}#validate`))throw Error(`Unsupported schema version: ${e.schemaVersion}`);if(!Ue(e)){if(!(e.schemaVersion in Be)){const n=await je.get(e.schemaVersion);Be[e.schemaVersion]=await Re(n)}const n=Be[e.schemaVersion](e.schema,Ne);if(!n.valid)throw n}je.markValidated(e.id)}return await Le(`${e.schemaVersion}#validate`).compile(e,n),je.uri(e)},Ue=e=>e.id===e.schemaVersion||Ke(e.schema)&&"$vocabulary"in e.schema,_e=(e,n,t)=>{const[r]=t[e];return Le(r).interpret(e,n,t)};var ze={validate:Re,setMetaOutputFormat:e=>{Ne=e},FLAG:Ae,BASIC:Pe,DETAILED:Ee,VERBOSE:ke,addKeyword:Ve,getKeyword:Le,hasKeyword:Ce,defineVocabulary:(e,n)=>{Je[e]=n},addVocabulary:(e,n)=>{Object.entries(Je[n]).forEach(([n,t])=>{Ve(`${e}#${n}`,t)})},compileSchema:Fe,interpretSchema:_e};var Ge={compile:()=>void 0,interpret:()=>!0},We=async e=>Object.entries(await e),Xe=D(async(e,n)=>(await n).map(e)),He=D(async(e,n,t)=>(await t).reduce(async(n,t)=>e(await n,t),n)),Ze=D(async(e,n,t={})=>He(async(n,t)=>await e(t)?n.concat([t]):n,[],n,t)),Qe=D(async(e,n)=>{const t=await Xe(e,n);return(await Promise.all(t)).some(e=>e)}),Ye=D(async(e,n)=>{const t=await Xe(e,n);return(await Promise.all(t)).every(e=>e)}),en=D((e,n)=>e.reduce(async(e,n)=>n(await e),n)),nn={entries:We,map:Xe,filter:Ze,reduce:He,some:Qe,every:Ye,pipeline:en,all:e=>Promise.all(e),allValues:e=>en([We,He(async(e,[n,t])=>(e[n]=await t,e),{})],e)};var tn={compile:async(e,n)=>{const t=je.uri(e);if(!(t in n)){n[t]=!1;const r=je.value(e);n[t]=[`${e.schemaVersion}#validate`,je.uri(e),"boolean"==typeof r?r:await nn.pipeline([je.entries,nn.map(([n,t])=>[`${e.schemaVersion}#${n}`,t]),nn.filter(([e])=>ze.hasKeyword(e)),nn.map(async([e,t])=>{const r=await t,a=await ze.getKeyword(e).compile(r,n);return[e,je.uri(r),a]}),nn.all],e)]}},interpret:(e,n,t)=>{const[r,a,i]=t[e],s="boolean"==typeof i?i:i.every(([e,r,a])=>{const i=ze.getKeyword(e).interpret(a,n,t);return R.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:te.uri(n),valid:i}),i});return R.publishSync("result",{keyword:r,absoluteKeywordLocation:a,instanceLocation:te.uri(n),valid:s}),s}},rn={JsonSchema:ze,Schema:je,Instance:te,Keywords:{metaData:Ge,validate:tn}};const{JsonSchema:an,Schema:sn,Instance:on}=rn;var cn={compile:async(e,n)=>{let t;try{const n=await sn.sibling("items",e);t=sn.value(n)}catch(e){}const r=Array.isArray(t)?t.length:Number.MAX_SAFE_INTEGER,a=sn.value(e);return"boolean"==typeof a?[r,a]:[r,await an.compileSchema(e,n)]},interpret:([e,n],t,r)=>!Array.isArray(on.value(t))||("string"==typeof n?on.every((t,a)=>a<e||an.interpretSchema(n,t,r),t):on.every((t,r)=>r<e||n,t))};const{JsonSchema:ln,Schema:dn,Instance:mn}=rn;var un={compile:async(e,n)=>{let t;try{const n=await dn.sibling("items",e);t=dn.value(n)}catch(e){}return[Array.isArray(t)?t.length:Number.MAX_SAFE_INTEGER,await ln.compileSchema(e,n)]},interpret:([e,n],t,r)=>!Array.isArray(mn.value(t))||mn.every((t,a)=>a<e||ln.interpretSchema(n,t,r),t)};var pn={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e};const{JsonSchema:fn,Schema:hn,Instance:yn}=rn,{isObject:vn}=pn;var gn={compile:async(e,n)=>{let t,r;try{const n=await hn.sibling("properties",e);t=Object.keys(hn.value(n))}catch(e){t=[]}try{const n=await hn.sibling("patternProperties",e);r=Object.keys(hn.value(n)).map(e=>new RegExp(e))}catch(e){r=[]}const a=hn.value(e);return"boolean"==typeof a?[t,r,a]:[t,r,await fn.compileSchema(e,n)]},interpret:([e,n,t],r,a)=>{const i=yn.value(r);if(!vn(i))return!0;const s=yn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t)));return"string"==typeof t?s.every(([,e])=>fn.interpretSchema(t,e,a)):0===s.length||t}};const{JsonSchema:$n,Schema:bn,Instance:wn}=rn,{isObject:xn}=pn;var On={compile:async(e,n)=>{let t,r;try{const n=await bn.sibling("properties",e);t=Object.keys(bn.value(n))}catch(e){t=[]}try{const n=await bn.sibling("patternProperties",e);r=Object.keys(bn.value(n)).map(e=>new RegExp(e))}catch(e){r=[]}return[t,r,await $n.compileSchema(e,n)]},interpret:([e,n,t],r,a)=>{const i=wn.value(r);return!xn(i)||wn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t))).every(([,e])=>$n.interpretSchema(t,e,a))}};const{JsonSchema:In,Schema:Sn}=rn;var jn={compile:(e,n)=>nn.pipeline([Sn.map(async e=>In.compileSchema(await e,n)),nn.all],e),interpret:(e,n,t)=>e.every(e=>In.interpretSchema(e,n,t))};const{JsonSchema:Kn,Schema:An}=rn;var Pn={compile:(e,n)=>nn.pipeline([An.map(async e=>Kn.compileSchema(await e,n)),nn.all],e),interpret:(e,n,t)=>e.some(e=>Kn.interpretSchema(e,n,t))},En=Object.keys,kn=JSON.stringify;var Nn=function(e){return""+function e(n,t){var r,a,i,s,o,c,l;if("string"==(l=typeof n))return kn(n);if(!0===n)return"true";if(!1===n)return"false";if(null===n)return"null";if(n instanceof Array){for(i="[",a=n.length-1,r=0;r<a;r++)i+=e(n[r],!1)+",";return a>-1&&(i+=e(n[r],!1)),i+"]"}if(n instanceof Object){if("function"==typeof n.toJSON)return e(n.toJSON(),t);for(a=(s=En(n).sort()).length,i="",r=0;r<a;)void 0!==(c=e(n[o=s[r]],!0))&&(r&&""!==i&&(i+=","),i+=kn(o)+":"+c),r++;return"{"+i+"}"}switch(l){case"function":case"undefined":return t?void 0:null;default:return isFinite(n)?n:null}}(e,!1)};const{Schema:Rn,Instance:qn}=rn;var Dn={compile:e=>Nn(Rn.value(e)),interpret:(e,n)=>Nn(qn.value(n))===e};const{JsonSchema:Tn,Instance:Mn}=rn;var Ln={compile:(e,n)=>Tn.compileSchema(e,n),interpret:(e,n,t)=>{const r=Mn.value(n);return!Array.isArray(r)||Mn.some(n=>Tn.interpretSchema(e,n,t),n)}};const{JsonSchema:Cn,Schema:Vn,Instance:Jn}=rn;var Bn={compile:async(e,n)=>{const t={};t.contains=await Cn.compileSchema(e,n);try{const n=await Vn.sibling("minContains",e);t.minContains=Vn.value(n)}catch(e){t.minContains=1}try{const n=await Vn.sibling("maxContains",e);t.maxContains=Vn.value(n)}catch(e){t.maxContains=Number.MAX_SAFE_INTEGER}return t},interpret:({contains:e,minContains:n,maxContains:t},r,a)=>{const i=Jn.value(r);if(!Array.isArray(i))return!0;const s=Jn.reduce((n,t)=>Cn.interpretSchema(e,t,a)?n+1:n,0,r);return s>=n&&s<=t}};const{JsonSchema:Fn,Schema:Un}=rn;var _n={compile:async(e,n)=>{await nn.pipeline([Un.entries,nn.map(async([,e])=>Fn.compileSchema(await e,n)),nn.all],e)},interpret:()=>!0};const{JsonSchema:zn,Schema:Gn,Instance:Wn}=rn,{isObject:Xn}=pn;var Hn={compile:(e,n)=>nn.pipeline([Gn.entries,nn.map(async([e,t])=>{const r=await t,a=await Gn.value(r);return[e,Array.isArray(a)?a:await zn.compileSchema(r,n)]}),nn.all],e),interpret:(e,n,t)=>{const r=Wn.value(n);return!Xn(r)||e.every(([e,a])=>!(e in r)||(Array.isArray(a)?a.every(e=>e in r):zn.interpretSchema(a,n,t)))}};const{Schema:Zn,Instance:Qn}=rn,{isObject:Yn}=pn;var et={compile:e=>nn.pipeline([Zn.entries,nn.map(async([e,n])=>[e,await Zn.value(await n)]),nn.all],e),interpret:(e,n)=>{const t=Qn.value(n);return!Yn(t)||e.every(([e,n])=>!(e in t)||n.every(e=>e in t))}};const{JsonSchema:nt,Schema:tt,Instance:rt}=rn,{isObject:at}=pn;var it={compile:(e,n)=>nn.pipeline([tt.entries,nn.map(async([e,t])=>[e,await nt.compileSchema(await t,n)]),nn.all],e),interpret:(e,n,t)=>{const r=rt.value(n);return!at(r)||e.every(([e,a])=>!(e in r)||nt.interpretSchema(a,n,t))}};const{Schema:st,Instance:ot}=rn;var ct={compile:e=>st.value(e).map(Nn),interpret:(e,n)=>e.some(e=>Nn(ot.value(n))===e)};const{Schema:lt,Instance:dt}=rn;var mt={compile:async e=>lt.value(e),interpret:(e,n)=>{const t=dt.value(n);return"number"!=typeof t||t<e}};const{Schema:ut,Instance:pt}=rn;var ft={compile:async e=>ut.value(e),interpret:(e,n)=>{const t=pt.value(n);return"number"!=typeof t||t>e}};const{Schema:ht,Instance:yt}=rn;var vt={compile:async e=>ht.value(e),interpret:(e,n)=>{const t=yt.value(n);return"number"!=typeof t||"boolean"==typeof e||t<e}};const{Schema:gt,Instance:$t}=rn;var bt={compile:async e=>gt.value(e),interpret:(e,n)=>{const t=$t.value(n);return"number"!=typeof t||"boolean"==typeof e||t>e}};const{JsonSchema:wt,Schema:xt}=rn;var Ot={compile:async(e,n)=>{const t={};t.if=await wt.compileSchema(e,n);try{const r=await xt.sibling("then",e);t.then=await wt.compileSchema(r,n)}catch(e){}try{const r=await xt.sibling("else",e);t.else=await wt.compileSchema(r,n)}catch(e){}return t},interpret:(e,n,t)=>wt.interpretSchema(e.if,n,t)?!("then"in e)||wt.interpretSchema(e.then,n,t):!("else"in e)||wt.interpretSchema(e.else,n,t)};const{JsonSchema:It,Schema:St,Instance:jt}=rn;var Kt={compile:(e,n)=>Array.isArray(St.value(e))?nn.pipeline([St.map(e=>It.compileSchema(e,n)),nn.all],e):It.compileSchema(e,n),interpret:(e,n,t)=>!Array.isArray(jt.value(n))||("string"==typeof e?jt.every(n=>It.interpretSchema(e,n,t),n):jt.every((n,r)=>!(r in e)||It.interpretSchema(e[r],n,t),n))};const{Schema:At,Instance:Pt}=rn;var Et={compile:e=>At.value(e),interpret:(e,n)=>{const t=Pt.value(n);return!Array.isArray(t)||t.length<=e}};const{Schema:kt,Instance:Nt}=rn;var Rt={compile:e=>kt.value(e),interpret:(e,n)=>{const t=Nt.value(n);return"string"!=typeof t||t.length<=e}};const{Schema:qt,Instance:Dt}=rn;var Tt={compile:e=>qt.value(e),interpret:(e,n)=>{const t=Dt.value(n);return"string"!=typeof t||[...t].length<=e}};const{Schema:Mt,Instance:Lt}=rn,{isObject:Ct}=pn;var Vt={compile:e=>Mt.value(e),interpret:(e,n)=>{const t=Lt.value(n);return!Ct(t)||Object.keys(t).length<=e}};const{Schema:Jt,Instance:Bt}=rn;var Ft={compile:async e=>{let n;try{const t=await Jt.sibling("exclusiveMaximum",e);n=Jt.value(t)}catch(e){n=!1}return[Jt.value(e),n]},interpret:([e,n],t)=>{const r=Bt.value(t);return"number"!=typeof r||(n?r<e:r<=e)}};const{Schema:Ut,Instance:_t}=rn;var zt={compile:async e=>{let n;try{const t=await Ut.sibling("exclusiveMaximum",e),r=Ut.value(t);n="boolean"==typeof r&&r}catch(e){n=!1}return[Ut.value(e),n]},interpret:([e,n],t)=>{const r=_t.value(t);return"number"!=typeof r||(n?r<e:r<=e)}};const{Schema:Gt,Instance:Wt}=rn;var Xt={compile:async e=>Gt.value(e),interpret:(e,n)=>{const t=Wt.value(n);return"number"!=typeof t||t<=e}};const{Schema:Ht,Instance:Zt}=rn;var Qt={compile:e=>Ht.value(e),interpret:(e,n)=>{const t=Zt.value(n);return!Array.isArray(t)||t.length>=e}};const{Schema:Yt,Instance:er}=rn;var nr={compile:e=>Yt.value(e),interpret:(e,n)=>{const t=er.value(n);return"string"!=typeof t||t.length>=e}};const{Schema:tr,Instance:rr}=rn;var ar={compile:e=>tr.value(e),interpret:(e,n)=>{const t=rr.value(n);return"string"!=typeof t||[...t].length>=e}};const{Schema:ir,Instance:sr}=rn,{isObject:or}=pn;var cr={compile:e=>ir.value(e),interpret:(e,n)=>{const t=sr.value(n);return!or(t)||Object.keys(t).length>=e}};const{Schema:lr,Instance:dr}=rn;var mr={compile:async e=>{let n;try{const t=await lr.sibling("exclusiveMinimum",e);n=lr.value(t)}catch(e){n=!1}return[lr.value(e),n]},interpret:([e,n],t)=>{const r=dr.value(t);return"number"!=typeof r||(n?r>e:r>=e)}};const{Schema:ur,Instance:pr}=rn;var fr={compile:async e=>{let n;try{const t=await ur.sibling("exclusiveMinimum",e),r=ur.value(t);n="boolean"==typeof r&&r}catch(e){n=!1}return[ur.value(e),n]},interpret:([e,n],t)=>{const r=pr.value(t);return"number"!=typeof r||(n?r>e:r>=e)}};const{Schema:hr,Instance:yr}=rn;var vr={compile:async e=>hr.value(e),interpret:(e,n)=>{const t=yr.value(n);return"number"!=typeof t||t>=e}};const{Schema:gr,Instance:$r}=rn,br=(e,n)=>Math.abs(e-n)<Number.EPSILON;var wr={compile:e=>gr.value(e),interpret:(e,n)=>{const t=$r.value(n);if("number"!=typeof t)return!0;const r=t%e;return br(0,r)||br(e,r)}};const{JsonSchema:xr}=rn;var Or={compile:(e,n)=>xr.compileSchema(e,n),interpret:(e,n,t)=>!xr.interpretSchema(e,n,t)};const{JsonSchema:Ir,Schema:Sr}=rn;var jr={compile:(e,n)=>nn.pipeline([Sr.map(async e=>Ir.compileSchema(await e,n)),nn.all],e),interpret:(e,n,t)=>{let r=0;for(const a of e)if(Ir.interpretSchema(a,n,t)&&r++,r>1)break;return 1===r}};const{Schema:Kr,Instance:Ar}=rn;var Pr={compile:e=>new RegExp(Kr.value(e)),interpret:(e,n)=>{const t=Ar.value(n);return"string"!=typeof t||e.test(t)}};const{JsonSchema:Er,Schema:kr,Instance:Nr}=rn,{isObject:Rr}=pn;var qr={compile:(e,n)=>nn.pipeline([kr.entries,nn.map(async([e,t])=>[new RegExp(e),await Er.compileSchema(await t,n)]),nn.all],e),interpret:(e,n,t)=>{const r=Nr.value(n);return!Rr(r)||e.every(([e,r])=>Nr.entries(n).filter(([n])=>e.test(n)).every(([,e])=>Er.interpretSchema(r,e,t)))}};const{JsonSchema:Dr,Schema:Tr,Instance:Mr}=rn,{isObject:Lr}=pn;var Cr={compile:(e,n)=>nn.pipeline([Tr.entries,nn.reduce(async(e,[t,r])=>(e[t]=await Dr.compileSchema(await r,n),e),{})],e),interpret:(e,n,t)=>!Lr(Mr.value(n))||Mr.entries(n).filter(([n])=>n in e).every(([n,r])=>Dr.interpretSchema(e[n],r,t))};const{JsonSchema:Vr,Instance:Jr}=rn,{isObject:Br}=pn;var Fr={compile:(e,n)=>Vr.compileSchema(e,n),interpret:(e,n,t)=>{const r=Jr.value(n);return!Br(r)||Object.keys(r).every(n=>Vr.interpretSchema(e,Jr.cons(n),t))}};const{JsonSchema:Ur}=rn;var _r={compile:async(e,n)=>Ur.compileSchema(e,n),interpret:(e,n,t)=>Ur.interpretSchema(e,n,t)};const{JsonSchema:zr}=rn;var Gr={compile:(e,n)=>zr.compileSchema(e,n),interpret:(e,n,t)=>zr.interpretSchema(e,n,t)};const{Schema:Wr,Instance:Xr}=rn,{isObject:Hr}=pn;var Zr={compile:e=>Wr.value(e),interpret:(e,n)=>{const t=Xr.value(n);return!Hr(t)||e.every(e=>e in t)}};const{Schema:Qr,Instance:Yr}=rn,{isObject:ea}=pn,na={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:ea,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e};var ta={compile:e=>Qr.value(e),interpret:(e,n)=>{const t=Yr.value(n);return"string"==typeof e?na[e](t):e.some(e=>na[e](t))}};const{Schema:ra,Instance:aa}=rn;var ia={compile:e=>ra.value(e),interpret:(e,n)=>{if(!1===e)return!0;const t=aa.map(e=>Nn(aa.value(e)),n);return new Set(t).size===t.length}};const{Keywords:sa}=rn;var oa={additionalItems:cn,additionalItems6:un,additionalProperties:gn,additionalProperties6:On,allOf:jn,anyOf:Pn,const:Dn,contains:Ln,contains201909:Bn,definitions:_n,dependencies:Hn,dependentRequired:et,dependentSchemas:it,enum:ct,exclusiveMaximum:mt,exclusiveMinimum:ft,exclusiveMaximumOas31:vt,exclusiveMinimumOas31:bt,ifThenElse:Ot,items:Kt,maxItems:Et,maxLength:Rt,maxLength6:Tt,maxProperties:Vt,maximumExclusiveMaximum:Ft,maximumExclusiveMaximumOas31:zt,maximum:Xt,metaData:sa.metaData,minItems:Qt,minLength:nr,minLength6:ar,minProperties:cr,minimumExclusiveMinimum:mr,minimumExclusiveMinimumOas31:fr,minimum:vr,multipleOf:wr,not:Or,oneOf:jr,pattern:Pr,patternProperties:qr,properties:Cr,propertyNames:Fr,$recursiveRef:_r,$ref:Gr,required:Zr,type:ta,uniqueItems:ia,validate:sa.validate};const{JsonSchema:ca,Schema:la}=rn,da="http://json-schema.org/draft-04/schema";la.setConfig(da,"jsonReference",!0),la.setConfig(da,"idToken","id"),la.setConfig(da,"anchorToken","id"),la.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),ca.addKeyword(`${da}#validate`,oa.validate),ca.addKeyword(`${da}#additionalItems`,oa.additionalItems),ca.addKeyword(`${da}#additionalProperties`,oa.additionalProperties),ca.addKeyword(`${da}#allOf`,oa.allOf),ca.addKeyword(`${da}#anyOf`,oa.anyOf),ca.addKeyword(`${da}#default`,oa.metaData),ca.addKeyword(`${da}#definitions`,oa.definitions),ca.addKeyword(`${da}#dependencies`,oa.dependencies),ca.addKeyword(`${da}#description`,oa.metaData),ca.addKeyword(`${da}#enum`,oa.enum),ca.addKeyword(`${da}#format`,oa.metaData),ca.addKeyword(`${da}#items`,oa.items),ca.addKeyword(`${da}#maxItems`,oa.maxItems),ca.addKeyword(`${da}#maxLength`,oa.maxLength),ca.addKeyword(`${da}#maxProperties`,oa.maxProperties),ca.addKeyword(`${da}#maximum`,oa.maximumExclusiveMaximum),ca.addKeyword(`${da}#minItems`,oa.minItems),ca.addKeyword(`${da}#minLength`,oa.minLength),ca.addKeyword(`${da}#minProperties`,oa.minProperties),ca.addKeyword(`${da}#minimum`,oa.minimumExclusiveMinimum),ca.addKeyword(`${da}#multipleOf`,oa.multipleOf),ca.addKeyword(`${da}#not`,oa.not),ca.addKeyword(`${da}#oneOf`,oa.oneOf),ca.addKeyword(`${da}#pattern`,oa.pattern),ca.addKeyword(`${da}#patternProperties`,oa.patternProperties),ca.addKeyword(`${da}#properties`,oa.properties),ca.addKeyword(`${da}#required`,oa.required),ca.addKeyword(`${da}#title`,oa.metaData),ca.addKeyword(`${da}#type`,oa.type),ca.addKeyword(`${da}#uniqueItems`,oa.uniqueItems);const ma="http://json-schema.org/draft-04/hyper-schema";la.setConfig(ma,"jsonReference",!0),la.setConfig(ma,"idToken","id"),la.setConfig(ma,"anchorToken","id"),la.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-04/hyper-schema#",\n    "id": "http://json-schema.org/draft-04/hyper-schema#",\n    "title": "JSON Hyper-Schema",\n    "allOf": [\n        {"$ref": "http://json-schema.org/draft-04/schema#"}\n    ],\n    "properties": {\n        "additionalItems": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "additionalProperties": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "dependencies": {\n            "additionalProperties": {\n                "anyOf": [\n                    {"$ref": "#"},\n                    {"type": "array"}\n                ]\n            }\n        },\n        "items": {\n            "anyOf": [\n                {"$ref": "#"},\n                {"$ref": "#/definitions/schemaArray"}\n            ]\n        },\n        "definitions": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "patternProperties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "properties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "allOf": {"$ref": "#/definitions/schemaArray"},\n        "anyOf": {"$ref": "#/definitions/schemaArray"},\n        "oneOf": {"$ref": "#/definitions/schemaArray"},\n        "not": { "$ref": "#" },\n\n        "links": {\n            "type": "array",\n            "items": {"$ref": "#/definitions/linkDescription"}\n        },\n        "fragmentResolution": {\n            "type": "string"\n        },\n        "media": {\n            "type": "object",\n            "properties": {\n                "type": {\n                    "description": "A media type, as described in RFC 2046",\n                    "type": "string"\n                },\n                "binaryEncoding": {\n                    "description": "A content encoding scheme, as described in RFC 2045",\n                    "type": "string"\n                }\n            }\n        },\n        "pathStart": {\n            "description": "Instances\' URIs must start with this value for this schema to apply to them",\n            "type": "string",\n            "format": "uri"\n        }\n    },\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "items": {"$ref": "#"}\n        },\n        "linkDescription": {\n            "title": "Link Description Object",\n            "type": "object",\n            "required": ["href", "rel"],\n            "properties": {\n                "href": {\n                    "description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",\n                    "type": "string"\n                },\n                "rel": {\n                    "description": "relation to the target resource of the link",\n                    "type": "string"\n                },\n                "title": {\n                    "description": "a title for the link",\n                    "type": "string"\n                },\n                "targetSchema": {\n                    "description": "JSON Schema describing the link target",\n                    "$ref": "#"\n                },\n                "mediaType": {\n                    "description": "media type (as defined by RFC 2046) describing the link target",\n                    "type": "string"\n                },\n                "method": {\n                    "description": "method for requesting the target of the link (e.g. for HTTP this might be \\"GET\\" or \\"DELETE\\")",\n                    "type": "string"\n                },\n                "encType": {\n                    "description": "The media type in which to submit data along with the request",\n                    "type": "string",\n                    "default": "application/json"\n                },\n                "schema": {\n                    "description": "Schema describing the data to submit along with the request",\n                    "$ref": "#"\n                }\n            }\n        },\n        "readOnly": {\n            "description": "If true, indicates that the value of this property is controlled by the server.",\n            "type": "boolean",\n            "default": false\n        }\n    },\n    "links": [\n        {\n            "rel": "self",\n            "href": "{+id}"\n        },\n        {\n            "rel": "full",\n            "href": "{+($ref)}"\n        }\n    ]\n}')),ca.addKeyword(`${ma}#validate`,oa.validate),ca.addKeyword(`${ma}#additionalItems`,oa.additionalItems),ca.addKeyword(`${ma}#additionalProperties`,oa.additionalProperties),ca.addKeyword(`${ma}#allOf`,oa.allOf),ca.addKeyword(`${ma}#anyOf`,oa.anyOf),ca.addKeyword(`${ma}#default`,oa.metaData),ca.addKeyword(`${ma}#definitions`,oa.definitions),ca.addKeyword(`${ma}#dependencies`,oa.dependencies),ca.addKeyword(`${ma}#description`,oa.metaData),ca.addKeyword(`${ma}#enum`,oa.enum),ca.addKeyword(`${ma}#format`,oa.metaData),ca.addKeyword(`${ma}#fragmentResolution`,oa.metaData),ca.addKeyword(`${ma}#items`,oa.items),ca.addKeyword(`${ma}#maxItems`,oa.maxItems),ca.addKeyword(`${ma}#minProperties`,oa.minProperties),ca.addKeyword(`${ma}#maxProperties`,oa.maxProperties),ca.addKeyword(`${ma}#maximum`,oa.maximumExclusiveMaximum),ca.addKeyword(`${ma}#media`,oa.metaData),ca.addKeyword(`${ma}#minItems`,oa.minItems),ca.addKeyword(`${ma}#minLength`,oa.minLength),ca.addKeyword(`${ma}#maxLength`,oa.maxLength),ca.addKeyword(`${ma}#minimum`,oa.minimumExclusiveMinimum),ca.addKeyword(`${ma}#multipleOf`,oa.multipleOf),ca.addKeyword(`${ma}#links`,oa.metaData),ca.addKeyword(`${ma}#not`,oa.not),ca.addKeyword(`${ma}#oneOf`,oa.oneOf),ca.addKeyword(`${ma}#pathStart`,oa.metaData),ca.addKeyword(`${ma}#pattern`,oa.pattern),ca.addKeyword(`${ma}#patternProperties`,oa.patternProperties),ca.addKeyword(`${ma}#properties`,oa.properties),ca.addKeyword(`${ma}#readOnly`,oa.metaData),ca.addKeyword(`${ma}#required`,oa.required),ca.addKeyword(`${ma}#title`,oa.metaData),ca.addKeyword(`${ma}#type`,oa.type),ca.addKeyword(`${ma}#uniqueItems`,oa.uniqueItems);const{JsonSchema:ua,Schema:pa}=rn,fa="http://json-schema.org/draft-06/schema";pa.setConfig(fa,"jsonReference",!0),pa.setConfig(fa,"idToken","$id"),pa.setConfig(fa,"anchorToken","$id"),pa.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),ua.addKeyword(`${fa}#validate`,oa.validate),ua.addKeyword(`${fa}#additionalItems`,oa.additionalItems6),ua.addKeyword(`${fa}#additionalProperties`,oa.additionalProperties6),ua.addKeyword(`${fa}#allOf`,oa.allOf),ua.addKeyword(`${fa}#anyOf`,oa.anyOf),ua.addKeyword(`${fa}#const`,oa.const),ua.addKeyword(`${fa}#contains`,oa.contains),ua.addKeyword(`${fa}#default`,oa.metaData),ua.addKeyword(`${fa}#definitions`,oa.definitions),ua.addKeyword(`${fa}#dependencies`,oa.dependencies),ua.addKeyword(`${fa}#description`,oa.metaData),ua.addKeyword(`${fa}#enum`,oa.enum),ua.addKeyword(`${fa}#examples`,oa.metaData),ua.addKeyword(`${fa}#exclusiveMaximum`,oa.exclusiveMaximum),ua.addKeyword(`${fa}#exclusiveMinimum`,oa.exclusiveMinimum),ua.addKeyword(`${fa}#format`,oa.metaData),ua.addKeyword(`${fa}#items`,oa.items),ua.addKeyword(`${fa}#maxItems`,oa.maxItems),ua.addKeyword(`${fa}#maxLength`,oa.maxLength6),ua.addKeyword(`${fa}#maxProperties`,oa.maxProperties),ua.addKeyword(`${fa}#maximum`,oa.maximum),ua.addKeyword(`${fa}#minItems`,oa.minItems),ua.addKeyword(`${fa}#minLength`,oa.minLength6),ua.addKeyword(`${fa}#minProperties`,oa.minProperties),ua.addKeyword(`${fa}#minimum`,oa.minimum),ua.addKeyword(`${fa}#multipleOf`,oa.multipleOf),ua.addKeyword(`${fa}#not`,oa.not),ua.addKeyword(`${fa}#oneOf`,oa.oneOf),ua.addKeyword(`${fa}#pattern`,oa.pattern),ua.addKeyword(`${fa}#patternProperties`,oa.patternProperties),ua.addKeyword(`${fa}#properties`,oa.properties),ua.addKeyword(`${fa}#propertyNames`,oa.propertyNames),ua.addKeyword(`${fa}#required`,oa.required),ua.addKeyword(`${fa}#title`,oa.metaData),ua.addKeyword(`${fa}#type`,oa.type),ua.addKeyword(`${fa}#uniqueItems`,oa.uniqueItems);const{JsonSchema:ha,Schema:ya}=rn,va="http://json-schema.org/draft-07/schema";ya.setConfig(va,"jsonReference",!0),ya.setConfig(va,"idToken","$id"),ya.setConfig(va,"anchorToken","$id"),ya.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),ha.addKeyword(`${va}#validate`,oa.validate),ha.addKeyword(`${va}#additionalItems`,oa.additionalItems6),ha.addKeyword(`${va}#additionalProperties`,oa.additionalProperties6),ha.addKeyword(`${va}#allOf`,oa.allOf),ha.addKeyword(`${va}#anyOf`,oa.anyOf),ha.addKeyword(`${va}#const`,oa.const),ha.addKeyword(`${va}#contains`,oa.contains),ha.addKeyword(`${va}#default`,oa.metaData),ha.addKeyword(`${va}#definitions`,oa.definitions),ha.addKeyword(`${va}#dependencies`,oa.dependencies),ha.addKeyword(`${va}#description`,oa.metaData),ha.addKeyword(`${va}#enum`,oa.enum),ha.addKeyword(`${va}#exclusiveMaximum`,oa.exclusiveMaximum),ha.addKeyword(`${va}#exclusiveMinimum`,oa.exclusiveMinimum),ha.addKeyword(`${va}#format`,oa.metaData),ha.addKeyword(`${va}#if`,oa.ifThenElse),ha.addKeyword(`${va}#items`,oa.items),ha.addKeyword(`${va}#maxItems`,oa.maxItems),ha.addKeyword(`${va}#maxLength`,oa.maxLength6),ha.addKeyword(`${va}#maxProperties`,oa.maxProperties),ha.addKeyword(`${va}#maximum`,oa.maximum),ha.addKeyword(`${va}#minItems`,oa.minItems),ha.addKeyword(`${va}#minLength`,oa.minLength6),ha.addKeyword(`${va}#minProperties`,oa.minProperties),ha.addKeyword(`${va}#minimum`,oa.minimum),ha.addKeyword(`${va}#multipleOf`,oa.multipleOf),ha.addKeyword(`${va}#not`,oa.not),ha.addKeyword(`${va}#oneOf`,oa.oneOf),ha.addKeyword(`${va}#pattern`,oa.pattern),ha.addKeyword(`${va}#patternProperties`,oa.patternProperties),ha.addKeyword(`${va}#properties`,oa.properties),ha.addKeyword(`${va}#propertyNames`,oa.propertyNames),ha.addKeyword(`${va}#readOnly`,oa.metaData),ha.addKeyword(`${va}#required`,oa.required),ha.addKeyword(`${va}#title`,oa.metaData),ha.addKeyword(`${va}#type`,oa.type),ha.addKeyword(`${va}#uniqueItems`,oa.uniqueItems),ha.addKeyword(`${va}#writeOnly`,oa.metaData);const{JsonSchema:ga,Schema:$a}=rn,ba="https://json-schema.org/draft/2019-09/schema";$a.setConfig(ba,"keywordReference",!0),$a.setConfig(ba,"keywordRecursiveReference",!0),$a.setConfig(ba,"idToken","$id"),$a.setConfig(ba,"anchorToken","$anchor"),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),ga.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{$comment:oa.metaData,$defs:oa.definitions,$recursiveRef:oa.$recursiveRef,$ref:oa.$ref}),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),ga.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:oa.additionalItems,additionalProperties:oa.additionalProperties,allOf:oa.allOf,anyOf:oa.anyOf,contains:oa.contains201909,dependentSchemas:oa.dependentSchemas,if:oa.ifThenElse,items:oa.items,not:oa.not,oneOf:oa.oneOf,patternProperties:oa.patternProperties,properties:oa.properties,propertyNames:oa.propertyNames}),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ga.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:oa.const,dependentRequired:oa.dependentRequired,enum:oa.enum,exclusiveMaximum:oa.exclusiveMaximum,exclusiveMinimum:oa.exclusiveMinimum,maxItems:oa.maxItems,maxLength:oa.maxLength6,maxProperties:oa.maxProperties,maximum:oa.maximum,minItems:oa.minItems,minLength:oa.minLength6,minProperties:oa.minProperties,minimum:oa.minimum,multipleOf:oa.multipleOf,pattern:oa.pattern,required:oa.required,type:oa.type,uniqueItems:oa.uniqueItems}),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),ga.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:oa.metaData,deprecated:oa.metaData,description:oa.metaData,examples:oa.metaData,readOnly:oa.metaData,title:oa.metaData,writeOnly:oa.metaData}),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),ga.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:oa.metaData,contentMediaType:oa.metaData,contentSchema:oa.metaData}),$a.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),ga.addKeyword(`${ba}#validate`,oa.validate),ga.addVocabulary(ba,"https://json-schema.org/draft/2019-09/vocab/core"),ga.addVocabulary(ba,"https://json-schema.org/draft/2019-09/vocab/applicator"),ga.addVocabulary(ba,"https://json-schema.org/draft/2019-09/vocab/validation"),ga.addVocabulary(ba,"https://json-schema.org/draft/2019-09/vocab/meta-data"),ga.addVocabulary(ba,"https://json-schema.org/draft/2019-09/vocab/content");const{JsonSchema:wa,Schema:xa}=rn,Oa="https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10";xa.setConfig(Oa,"keywordReference",!0),xa.setConfig(Oa,"keywordRecursiveReference",!0),xa.setConfig(Oa,"idToken","$id"),xa.setConfig(Oa,"anchorToken","$anchor"),xa.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/validation/2019-10",\n    "$schema": "https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10",\n    "$vocabulary": {\n        "https://spec.openapis.org/oas/3.1/vocab/validation/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "$comment": "This is an alternate meta-schema for the standard validation vocabulary.  It is identical to the standard validation meta-schema except that it omits exclusiveMinimum and exclusiveMaximum, which are described by the OpenAPI extensions meta-schema.",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),wa.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/validation/2019-10",{const:oa.const,dependentRequired:oa.dependentRequired,enum:oa.enum,maxItems:oa.maxItems,maxLength:oa.maxLength6,maxProperties:oa.maxProperties,minItems:oa.minItems,minLength:oa.minLength6,minProperties:oa.minProperties,multipleOf:oa.multipleOf,pattern:oa.pattern,required:oa.required,type:oa.type,uniqueItems:oa.uniqueItems}),xa.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/extensions/2019-10",\n    "$schema": "https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10",\n    "$vocabulary": {\n        "https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "example": true,\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "nullable": {\n            "type": "boolean",\n            "default": false\n        },\n        "discriminator": {\n            "$ref": "#/$defs/Discriminator"\n        },\n        "externalDocs": {\n            "$ref": "#/$defs/ExternalDocs"\n        },\n        "xml": {\n            "$ref": "#/$defs/Xml"\n        }\n    },\n    "patternProperties": {\n        "^x-": true\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "Discriminator": {\n            "type": "object",\n            "required": ["propertyName"],\n            "properties": {\n                "propertyName": {\n                    "type": "string"\n                },\n                "mapping": {\n                    "additionalProperties": {\n                        "type": "string"\n                    }\n                }\n            },\n            "additionalProperties": false\n        },\n        "ExternalDocs": {\n            "type": "object",\n            "required": ["url"],\n            "properties": {\n                "url": {\n                    "type": "string",\n                    "format": "uri-reference"\n                },\n                "description": {\n                    "type": "string"\n                }\n            },\n            "patternProperties": {\n                "^x-": true\n            },\n            "additionalProperties": false\n        },\n        "Xml": {\n            "type": "object",\n            "properties": {\n                "name": {\n                    "type": "string"\n                },\n                "namespace": {\n                    "type": "string",\n                    "format": "uri"\n                },\n                "prefix": {\n                    "type": "string"\n                },\n                "attribute": {\n                    "type": "boolean"\n                },\n                "wrapped": {\n                    "type": "boolean"\n                }\n            },\n            "patternProperties": {\n                "^x-": true\n            },\n            "additionalProperties": false\n        }\n    }\n}')),wa.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10",{discriminator:oa.metaData,example:oa.metaData,exclusiveMaximum:oa.exclusiveMaximumOas31,exclusiveMinimum:oa.exclusiveMinimumOas31,externalDocs:oa.metaData,maximum:oa.maximumExclusiveMaximumOas31,minimum:oa.minimumExclusiveMinimumOas31,nullable:oa.metaData,xml:oa.metaData}),xa.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10",\n    "$schema": "https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true,\n        "https://spec.openapis.org/oas/3.1/vocab/validation/2019-10": true,\n        "https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/core"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/applicator"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/meta-data"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/format"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/content"},\n        {"$ref": "https://spec.openapis.org/oas/3.1/meta/validation/2019-10"},\n        {"$ref": "https://spec.openapis.org/oas/3.1/meta/extensions/2019-10"}\n    ],\n    "type": ["object", "boolean"],\n    "unevaluatedProperties": false\n}')),wa.addKeyword(`${Oa}#validate`,oa.validate),wa.addVocabulary(Oa,"https://json-schema.org/draft/2019-09/vocab/core"),wa.addVocabulary(Oa,"https://json-schema.org/draft/2019-09/vocab/applicator"),wa.addVocabulary(Oa,"https://json-schema.org/draft/2019-09/vocab/meta-data"),wa.addVocabulary(Oa,"https://json-schema.org/draft/2019-09/vocab/content"),wa.addVocabulary(Oa,"https://spec.openapis.org/oas/3.1/vocab/validation/2019-10"),wa.addVocabulary(Oa,"https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10");const{JsonSchema:Ia,Schema:Sa}=rn;var ja={add:Sa.add,get:Sa.get,validate:Ia.validate,setMetaOutputFormat:Ia.setMetaOutputFormat,FLAG:Ia.FLAG,BASIC:Ia.BASIC,DETAILED:Ia.DETAILED,VERBOSE:Ia.VERBOSE};const Ka='(?:[^\\"]|\\(?:["/\\bfnrt]|u[0-9a-fA-F]{4})',Aa=`"${Ka}*"`,Pa=`"${Ka}*"(?=:)`;var Ea=N(function(e){var n,t;n=k,t=function(){var e=Object.prototype.hasOwnProperty,n=Object.prototype.toString,t="boolean"==typeof(new RegExp).sticky;function r(e){return e&&"[object RegExp]"===n.call(e)}function a(e){return e&&"object"==typeof e&&!r(e)&&!Array.isArray(e)}function i(e){return"("+e+")"}function s(e){return e.length?"(?:"+e.map(function(e){return"(?:"+e+")"}).join("|")+")":"(?!)"}function o(e){if("string"==typeof e)return"(?:"+e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")+")";if(r(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function c(n,t){if(a(t)||(t={match:t}),t.include)throw new Error("Matching rules cannot also include states");var i={defaultType:n,lineBreaks:!!t.error||!!t.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var s in t)e.call(t,s)&&(i[s]=t[s]);if("string"==typeof i.type&&n!==i.type)throw new Error("Type transform cannot be a string (type '"+i.type+"' for token '"+n+"')");var o=i.match;return i.match=Array.isArray(o)?o:o?[o]:[],i.match.sort(function(e,n){return r(e)&&r(n)?0:r(n)?-1:r(e)?1:n.length-e.length}),i}function l(e){return Array.isArray(e)?function(e){for(var n=[],t=0;t<e.length;t++){var r=e[t];if(r.include)for(var a=[].concat(r.include),i=0;i<a.length;i++)n.push({include:a[i]});else{if(!r.type)throw new Error("Rule has no type: "+JSON.stringify(r));n.push(c(r.type,r))}}return n}(e):function(e){for(var n=Object.getOwnPropertyNames(e),t=[],r=0;r<n.length;r++){var i=n[r],s=e[i],o=[].concat(s);if("include"!==i){var l=[];o.forEach(function(e){a(e)?(l.length&&t.push(c(i,l)),t.push(c(i,e)),l=[]):l.push(e)}),l.length&&t.push(c(i,l))}else for(var d=0;d<o.length;d++)t.push({include:o[d]})}return t}(e)}var d=c("error",{lineBreaks:!0,shouldThrow:!0});function m(e,n){for(var a=null,c=Object.create(null),l=!0,m=null,u=[],p=[],f=0;f<e.length;f++)e[f].fallback&&(l=!1);for(f=0;f<e.length;f++){var h=e[f];if(h.include)throw new Error("Inheritance is not allowed in stateless lexers");if(h.error||h.fallback){if(a)throw!h.fallback==!a.fallback?new Error("Multiple "+(h.fallback?"fallback":"error")+" rules not allowed (for token '"+h.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+h.defaultType+"')");a=h}var y=h.match.slice();if(l)for(;y.length&&"string"==typeof y[0]&&1===y[0].length;){c[y.shift().charCodeAt(0)]=h}if(h.pop||h.push||h.next){if(!n)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+h.defaultType+"')");if(h.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+h.defaultType+"')")}if(0!==y.length){l=!1,u.push(h);for(var v=0;v<y.length;v++){var g=y[v];if(r(g))if(null===m)m=g.unicode;else if(m!==g.unicode&&!1===h.fallback)throw new Error("If one rule is /u then all must be")}var $=s(y.map(o)),b=new RegExp($);if(b.test(""))throw new Error("RegExp matches empty string: "+b);if(new RegExp("|"+$).exec("").length-1>0)throw new Error("RegExp has capture groups: "+b+"\nUse (?: … ) instead");if(!h.lineBreaks&&b.test("\n"))throw new Error("Rule should declare lineBreaks: "+b);p.push(i($))}}var w=a&&a.fallback,x=t&&!w?"ym":"gm",O=t||w?"":"|";return!0===m&&(x+="u"),{regexp:new RegExp(s(p)+O,x),groups:u,fast:c,error:a||d}}function u(e,n,t){var r=e&&(e.push||e.next);if(r&&!t[r])throw new Error("Missing state '"+r+"' (in token '"+e.defaultType+"' of state '"+n+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+n+"')")}var p=function(e,n){this.startState=n,this.states=e,this.buffer="",this.stack=[],this.reset()};p.prototype.reset=function(e,n){return this.buffer=e||"",this.index=0,this.line=n?n.line:1,this.col=n?n.col:1,this.queuedToken=n?n.queuedToken:null,this.queuedThrow=n?n.queuedThrow:null,this.setState(n?n.state:this.startState),this.stack=n&&n.stack?n.stack.slice():[],this},p.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},p.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var n=this.states[e];this.groups=n.groups,this.error=n.error,this.re=n.regexp,this.fast=n.fast}},p.prototype.popState=function(){this.setState(this.stack.pop())},p.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)};var f=t?function(e,n){return e.exec(n)}:function(e,n){var t=e.exec(n);return 0===t[0].length?null:t};function h(){return this.value}if(p.prototype._getGroup=function(e){for(var n=this.groups.length,t=0;t<n;t++)if(void 0!==e[t+1])return this.groups[t];throw new Error("Cannot find token type for matched text")},p.prototype.next=function(){var e=this.index;if(this.queuedGroup){var n=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",n}var t=this.buffer;if(e!==t.length){if(s=this.fast[t.charCodeAt(e)])return this._token(s,t.charAt(e),e);var r=this.re;r.lastIndex=e;var a=f(r,t),i=this.error;if(null==a)return this._token(i,t.slice(e,t.length),e);var s=this._getGroup(a),o=a[0];return i.fallback&&a.index!==e?(this.queuedGroup=s,this.queuedText=o,this._token(i,t.slice(e,a.index),e)):this._token(s,o,e)}},p.prototype._token=function(e,n,t){var r=0;if(e.lineBreaks){var a=/\n/g,i=1;if("\n"===n)r=1;else for(;a.exec(n);)r++,i=a.lastIndex}var s={type:"function"==typeof e.type&&e.type(n)||e.defaultType,value:"function"==typeof e.value?e.value(n):n,text:n,toString:h,offset:t,lineBreaks:r,line:this.line,col:this.col},o=n.length;if(this.index+=o,this.line+=r,0!==r?this.col=o-i+1:this.col+=o,e.shouldThrow)throw new Error(this.formatError(s,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),s},"undefined"!=typeof Symbol&&Symbol.iterator){var y=function(e){this.lexer=e};y.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},y.prototype[Symbol.iterator]=function(){return this},p.prototype[Symbol.iterator]=function(){return new y(this)}}return p.prototype.formatError=function(e,n){if(null==e){var t=this.buffer.slice(this.index);e={text:t,offset:this.index,lineBreaks:-1===t.indexOf("\n")?0:1,line:this.line,col:this.col}}var r=Math.max(0,e.offset-e.col+1),a=e.lineBreaks?e.text.indexOf("\n"):e.text.length,i=this.buffer.substring(r,e.offset+a);return n+=" at line "+e.line+" col "+e.col+":\n\n",n+="  "+i+"\n",n+="  "+Array(e.col).join(" ")+"^"},p.prototype.clone=function(){return new p(this.states,this.state)},p.prototype.has=function(e){return!0},{compile:function(e){var n=m(l(e));return new p({start:n},"start")},states:function(e,n){var t=e.$all?l(e.$all):[];delete e.$all;var r=Object.getOwnPropertyNames(e);n||(n=r[0]);for(var a=Object.create(null),i=0;i<r.length;i++)a[$=r[i]]=l(e[$]).concat(t);for(i=0;i<r.length;i++)for(var s=a[$=r[i]],o=Object.create(null),c=0;c<s.length;c++){var d=s[c];if(d.include){var f=[c,1];if(d.include!==$&&!o[d.include]){o[d.include]=!0;var h=a[d.include];if(!h)throw new Error("Cannot include nonexistent state '"+d.include+"' (in state '"+$+"')");for(var y=0;y<h.length;y++){var v=h[y];-1===s.indexOf(v)&&f.push(v)}}s.splice.apply(s,f),c--}}var g=Object.create(null);for(i=0;i<r.length;i++){var $;g[$=r[i]]=m(a[$],!0)}for(i=0;i<r.length;i++){var b=r[i],w=g[b],x=w.groups;for(c=0;c<x.length;c++)u(x[c],b,g);var O=Object.getOwnPropertyNames(w.fast);for(c=0;c<O.length;c++)u(w.fast[O[c]],b,g)}return new p(g,n)},error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:function(e){for(var n=Object.create(null),t=Object.create(null),r=Object.getOwnPropertyNames(e),a=0;a<r.length;a++){var i=r[a],s=e[i];(Array.isArray(s)?s:[s]).forEach(function(e){if((t[e.length]=t[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+i+"')");n[e]=i})}function o(e){return JSON.stringify(e)}var c="";for(var l in c+="switch (value.length) {\n",t){var d=t[l];c+="case "+l+":\n",c+="switch (value) {\n",d.forEach(function(e){var t=n[e];c+="case "+o(e)+": return "+o(t)+"\n"}),c+="}\n"}return c+="}\n",Function("value",c)}}},e.exports?e.exports=t():n.moo=t()}).compile({WS:{match:/(?:(?:\r?\n)|[ \t])+/,lineBreaks:!0},punctuation:/[:,]/,number:new RegExp("-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+][0-9]+)?"),property:new RegExp(Pa),string:new RegExp(Aa),grouping:["{","}","[","]"],keyword:["null","true","false"],other:/./});function ka(e,n,t){const r=e.slice();return r[4]=n[t],r}function Na(e){let n,t=e[4].value+"";return{c(){n=v(t)},l(e){n=g(e,t)},m(e,t){a(e,n,t)},p(e,r){4&r&&t!==(t=e[4].value+"")&&$(n,t)},d(e){e&&i(n)}}}function Ra(e){let n,t,r=e[4].value+"";return{c(){n=s("span"),t=v(r),this.h()},l(e){n=c(e,"SPAN",{class:!0});var a=l(n);t=g(a,r),a.forEach(i),this.h()},h(){m(n,"class","atom svelte-8fwnou")},m(e,r){a(e,n,r),u(n,t)},p(e,n){4&n&&r!==(r=e[4].value+"")&&$(t,r)},d(e){e&&i(n)}}}function qa(e){let n,t,r=e[4].value+"";return{c(){n=s("span"),t=v(r),this.h()},l(e){n=c(e,"SPAN",{class:!0});var a=l(n);t=g(a,r),a.forEach(i),this.h()},h(){m(n,"class","number svelte-8fwnou")},m(e,r){a(e,n,r),u(n,t)},p(e,n){4&n&&r!==(r=e[4].value+"")&&$(t,r)},d(e){e&&i(n)}}}function Da(e){let n,t,r,o,d=e[4].value.substring(1,e[4].value.length-1)+"";return{c(){n=v('"'),t=s("span"),r=v(d),o=v('"'),this.h()},l(e){n=g(e,'"'),t=c(e,"SPAN",{class:!0});var a=l(t);r=g(a,d),a.forEach(i),o=g(e,'"'),this.h()},h(){m(t,"class","string svelte-8fwnou")},m(e,i){a(e,n,i),a(e,t,i),u(t,r),a(e,o,i)},p(e,n){4&n&&d!==(d=e[4].value.substring(1,e[4].value.length-1)+"")&&$(r,d)},d(e){e&&i(n),e&&i(t),e&&i(o)}}}function Ta(e){let n,t,r,o,d=e[4].value.substring(1,e[4].value.length-1)+"";return{c(){n=v('"'),t=s("span"),r=v(d),o=v('"'),this.h()},l(e){n=g(e,'"'),t=c(e,"SPAN",{class:!0});var a=l(t);r=g(a,d),a.forEach(i),o=g(e,'"'),this.h()},h(){m(t,"class","property svelte-8fwnou")},m(e,i){a(e,n,i),a(e,t,i),u(t,r),a(e,o,i)},p(e,n){4&n&&d!==(d=e[4].value.substring(1,e[4].value.length-1)+"")&&$(r,d)},d(e){e&&i(n),e&&i(t),e&&i(o)}}}function Ma(e){let n,t,r=e[4].value+"";return{c(){n=s("span"),t=v(r),this.h()},l(e){n=c(e,"SPAN",{class:!0});var a=l(n);t=g(a,r),a.forEach(i),this.h()},h(){m(n,"class","grouping svelte-8fwnou")},m(e,r){a(e,n,r),u(n,t)},p(e,n){4&n&&r!==(r=e[4].value+"")&&$(t,r)},d(e){e&&i(n)}}}function La(e){let n;function t(e,n){return"grouping"===e[4].type?Ma:"property"===e[4].type?Ta:"string"===e[4].type?Da:"number"===e[4].type?qa:"literal"===e[4].type?Ra:Na}let s=t(e),o=s(e);return{c(){o.c(),n=r()},l(e){o.l(e),n=r()},m(e,t){o.m(e,t),a(e,n,t)},p(e,r){s===(s=t(e))&&o?o.p(e,r):(o.d(1),(o=s(e))&&(o.c(),o.m(n.parentNode,n)))},d(e){o.d(e),e&&i(n)}}}function Ca(e){let n,t,r,v,g,$,b=e[2],w=[];for(let n=0;n<b.length;n+=1)w[n]=La(ka(e,b,n));return{c(){n=s("div"),t=s("pre");for(let e=0;e<w.length;e+=1)w[e].c();r=o(),v=s("textarea"),this.h()},l(e){n=c(e,"DIV",{class:!0});var a=l(n);t=c(a,"PRE",{class:!0});var s=l(t);for(let e=0;e<w.length;e+=1)w[e].l(s);s.forEach(i),r=d(a),v=c(a,"TEXTAREA",{class:!0}),l(v).forEach(i),a.forEach(i),this.h()},h(){m(t,"class","highlighted svelte-8fwnou"),m(v,"class","src svelte-8fwnou"),m(n,"class",g="Editor "+e[1]+" svelte-8fwnou")},m(i,s,o){a(i,n,s),u(n,t);for(let e=0;e<w.length;e+=1)w[e].m(t,null);u(n,r),u(n,v),p(v,e[0]),o&&$(),$=f(v,"input",e[3])},p(e,[r]){if(4&r){let n;for(b=e[2],n=0;n<b.length;n+=1){const a=ka(e,b,n);w[n]?w[n].p(a,r):(w[n]=La(a),w[n].c(),w[n].m(t,null))}for(;n<w.length;n+=1)w[n].d(1);w.length=b.length}1&r&&p(v,e[0]),2&r&&g!==(g="Editor "+e[1]+" svelte-8fwnou")&&m(n,"class",g)},i:h,o:h,d(e){e&&i(n),y(w,e),$()}}}function Va(e,n,t){let r,{theme:a="solarized-dark"}=n,{value:i=""}=n;return e.$set=(e=>{"theme"in e&&t(1,a=e.theme),"value"in e&&t(0,i=e.value)}),e.$$.update=(()=>{1&e.$$.dirty&&t(2,(Ea.reset(i),r=Array.from(Ea)))}),[i,a,r,function(){i=this.value,t(0,i)}]}class Ja extends e{constructor(e){super(),n(this,e,Va,Ca,t,{theme:1,value:0})}}function Ba(e,n,t){const r=e.slice();return r[3]=n[t],r}function Fa(e){let n;function t(e,n){return e[2].absoluteKeywordLocation?_a:Ua}let s=t(e),o=s(e);return{c(){o.c(),n=r()},l(e){o.l(e),n=r()},m(e,t){o.m(e,t),a(e,n,t)},p(e,r){s===(s=t(e))&&o?o.p(e,r):(o.d(1),(o=s(e))&&(o.c(),o.m(n.parentNode,n)))},d(e){o.d(e),e&&i(n)}}}function Ua(e){let n,t=e[2]+"";return{c(){n=v(t)},l(e){n=g(e,t)},m(e,t){a(e,n,t)},p(e,r){1&r&&t!==(t=e[2]+"")&&$(n,t)},d(e){e&&i(n)}}}function _a(e){let n,t,r=e[2].errors,o=[];for(let n=0;n<r.length;n+=1)o[n]=Ga(Ba(e,r,n));return{c(){n=v("Invalid\n    "),t=s("ul");for(let e=0;e<o.length;e+=1)o[e].c()},l(e){n=g(e,"Invalid\n    "),t=c(e,"UL",{});var r=l(t);for(let e=0;e<o.length;e+=1)o[e].l(r);r.forEach(i)},m(e,r){a(e,n,r),a(e,t,r);for(let e=0;e<o.length;e+=1)o[e].m(t,null)},p(e,n){if(1&n){let a;for(r=e[2].errors,a=0;a<r.length;a+=1){const i=Ba(e,r,a);o[a]?o[a].p(i,n):(o[a]=Ga(i),o[a].c(),o[a].m(t,null))}for(;a<o.length;a+=1)o[a].d(1);o.length=r.length}},d(e){e&&i(n),e&&i(t),y(o,e)}}}function za(e){let n,t,r,o,d,p,f,h=e[3].instanceLocation+"",y=e[3].absoluteKeywordLocation+"";return{c(){n=s("li"),t=s("code"),r=v("instance"),o=v(h),d=v(" fails schema constraint "),p=s("code"),f=v(y),this.h()},l(e){n=c(e,"LI",{class:!0});var a=l(n);t=c(a,"CODE",{class:!0});var s=l(t);r=g(s,"instance"),o=g(s,h),s.forEach(i),d=g(a," fails schema constraint "),p=c(a,"CODE",{class:!0});var m=l(p);f=g(m,y),m.forEach(i),a.forEach(i),this.h()},h(){m(t,"class","svelte-1sdf2dp"),m(p,"class","svelte-1sdf2dp"),m(n,"class","svelte-1sdf2dp")},m(e,i){a(e,n,i),u(n,t),u(t,r),u(t,o),u(n,d),u(n,p),u(p,f)},p(e,n){1&n&&h!==(h=e[3].instanceLocation+"")&&$(o,h),1&n&&y!==(y=e[3].absoluteKeywordLocation+"")&&$(f,y)},d(e){e&&i(n)}}}function Ga(e){let n,t=!e[3].valid&&za(e);return{c(){t&&t.c(),n=r()},l(e){t&&t.l(e),n=r()},m(e,r){t&&t.m(e,r),a(e,n,r)},p(e,r){e[3].valid?t&&(t.d(1),t=null):t?t.p(e,r):((t=za(e)).c(),t.m(n.parentNode,n))},d(e){t&&t.d(e),e&&i(n)}}}function Wa(e){let n;return{c(){n=v("Valid")},l(e){n=g(e,"Valid")},m(e,t){a(e,n,t)},p:h,d(e){e&&i(n)}}}function Xa(e){let n;return{c(){n=v("Validating ...")},l(e){n=g(e,"Validating ...")},m(e,t){a(e,n,t)},p:h,d(e){e&&i(n)}}}function Ha(e){let n,t,s={ctx:e,current:null,token:null,pending:Xa,then:Wa,catch:Fa,value:1,error:2};return b(t=e[0],s),{c(){n=r(),s.block.c()},l(e){n=r(),s.block.l(e)},m(e,t){a(e,n,t),s.block.m(e,s.anchor=t),s.mount=(()=>n.parentNode),s.anchor=n},p(n,[r]){if(e=n,s.ctx=e,1&r&&t!==(t=e[0])&&b(t,s));else{const n=e.slice();n[1]=s.resolved,s.block.p(n,r)}},i:h,o:h,d(e){e&&i(n),s.block.d(e),s.token=null,s=null}}}function Za(e,n,t){let{results:r}=n;return e.$set=(e=>{"results"in e&&t(0,r=e.results)}),[r]}class Qa extends e{constructor(e){super(),n(this,e,Za,Ha,t,{results:0})}}function Ya(e){return{c:h,l:h,m:h,p:h,i:h,o:h,d:h}}function ei(e){let n;const t=new Qa({props:{results:e[3]}});return{c(){w(t.$$.fragment)},l(e){O(t.$$.fragment,e)},m(e,r){I(t,e,r),n=!0},p(e,n){const r={};8&n&&(r.results=e[3]),t.$set(r)},i(e){n||(S(t.$$.fragment,e),n=!0)},o(e){j(t.$$.fragment,e),n=!1},d(e){K(t,e)}}}function ni(e){return{c:h,l:h,m:h,p:h,i:h,o:h,d:h}}function ti(e){let n,t,r,p,f,h,y,$,k,N,R,q,D,T,M,L,C,V,J,B,F,U;function _(n){e[4].call(null,n)}let z={};void 0!==e[0]&&(z.value=e[0]);const G=new Ja({props:z});A.push(()=>P(G,"value",_));const W=new Qa({props:{results:e[2]}});function X(n){e[5].call(null,n)}let H={};void 0!==e[1]&&(H.value=e[1]);const Z=new Ja({props:H});A.push(()=>P(Z,"value",X));let Q={ctx:e,current:null,token:null,pending:ni,then:ei,catch:Ya,value:6,blocks:[,,,]};return b(B=e[2],Q),{c(){n=o(),t=s("h1"),r=v("JSON Schema Validator"),p=o(),f=s("main"),h=s("h2"),y=v("Schema"),$=o(),w(G.$$.fragment),N=o(),R=s("div"),w(W.$$.fragment),D=o(),T=s("h2"),M=v("Instance"),L=o(),w(Z.$$.fragment),V=o(),J=s("div"),Q.block.c(),this.h()},l(e){x('[data-svelte="svelte-1ggnpw2"]',document.head).forEach(i),n=d(e),t=c(e,"H1",{class:!0});var a=l(t);r=g(a,"JSON Schema Validator"),a.forEach(i),p=d(e),f=c(e,"MAIN",{class:!0});var s=l(f);h=c(s,"H2",{class:!0});var o=l(h);y=g(o,"Schema"),o.forEach(i),$=d(s),O(G.$$.fragment,s),N=d(s),R=c(s,"DIV",{class:!0});var m=l(R);O(W.$$.fragment,m),m.forEach(i),D=d(s),T=c(s,"H2",{class:!0});var u=l(T);M=g(u,"Instance"),u.forEach(i),L=d(s),O(Z.$$.fragment,s),V=d(s),J=c(s,"DIV",{class:!0});var v=l(J);Q.block.l(v),v.forEach(i),s.forEach(i),this.h()},h(){document.title="JSON Schema Validator",m(t,"class","svelte-1g7hysf"),m(h,"class","svelte-1g7hysf"),m(R,"class",q="results "+ii+" svelte-1g7hysf"),m(T,"class","svelte-1g7hysf"),m(J,"class",F="results "+ii+" svelte-1g7hysf"),m(f,"class","svelte-1g7hysf")},m(e,i){a(e,n,i),a(e,t,i),u(t,r),a(e,p,i),a(e,f,i),u(f,h),u(h,y),u(f,$),I(G,f,null),u(f,N),u(f,R),I(W,R,null),u(f,D),u(f,T),u(T,M),u(f,L),I(Z,f,null),u(f,V),u(f,J),Q.block.m(J,Q.anchor=null),Q.mount=(()=>J),Q.anchor=null,U=!0},p(n,[t]){e=n;const r={};!k&&1&t&&(k=!0,r.value=e[0],E(()=>k=!1)),G.$set(r);const a={};4&t&&(a.results=e[2]),W.$set(a);const i={};if(!C&&2&t&&(C=!0,i.value=e[1],E(()=>C=!1)),Z.$set(i),Q.ctx=e,4&t&&B!==(B=e[2])&&b(B,Q));else{const n=e.slice();n[6]=Q.resolved,Q.block.p(n,t)}},i(e){U||(S(G.$$.fragment,e),S(W.$$.fragment,e),S(Z.$$.fragment,e),S(Q.block),U=!0)},o(e){j(G.$$.fragment,e),j(W.$$.fragment,e),j(Z.$$.fragment,e);for(let e=0;e<3;e+=1){const n=Q.blocks[e];j(n)}U=!1},d(e){e&&i(n),e&&i(t),e&&i(p),e&&i(f),K(G),K(W),K(Z),Q.block.d(),Q.token=null,Q=null}}}const ri="https://json-schema.org/draft/2019-09/schema",ai="https://json-schema.hyperjump.io/schema",ii="solarized-dark";function si(e,n,t){let r,a,i=`{\n  "$schema": "${ri}",\n  "$id": "${ai}"\n}`,s="{}";return ja.setMetaOutputFormat(ja.BASIC),e.$$.update=(()=>{1&e.$$.dirty&&t(2,r=async function(){if(""!==i){ja.add(JSON.parse(i),ai,ri);const e=await ja.get(ai);return ja.validate(e)}}()),6&e.$$.dirty&&t(3,a=async function(){if(""!==s){let e;try{e=await r}catch(e){}if(e){const n=e(JSON.parse(s),ja.BASIC);if(n.valid)return n;throw n}}}())}),[i,s,r,a,function(e){t(0,i=e)},function(e){t(1,s=e)}]}export default class extends e{constructor(e){super(),n(this,e,si,ti,t,{})}}
