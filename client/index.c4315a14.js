import{S as e,i as t,s as n,e as r,t as a,c as i,a as s,b as o,d as c,f as l,g as u,h as m,n as p,j as f,k as d,l as h,m as v,o as y,p as g,r as $,q as b,u as x,v as w,w as I,x as j,y as O,z as E,A as S,B as A,C as P,D as k,E as N,F as T,G as q,H as R,I as C,J as M,K as D,L as V}from"./client.d4c8adeb.js";var L="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function X(e,t){return e(t={exports:{}},t.exports),t.exports}var J=X(function(e,t){!function(n,r){var a={};n.PubSub=a;var i=n.define;!function(e){var t={},n=-1;function r(e){var t;for(t in e)if(e.hasOwnProperty(t))return!0;return!1}function a(e,t,n){try{e(t,n)}catch(e){setTimeout(function(e){return function(){throw e}}(e),0)}}function i(e,t,n){e(t,n)}function s(e,n,r,s){var o,c=t[n],l=s?i:a;if(t.hasOwnProperty(n))for(o in c)c.hasOwnProperty(o)&&l(c[o],e,r)}function o(e,n,a,i){var o=function(e,t,n){return function(){var r=String(e),a=r.lastIndexOf(".");for(s(e,e,t,n);-1!==a;)r=r.substr(0,a),a=r.lastIndexOf("."),s(e,r,t,n)}}(e="symbol"==typeof e?e.toString():e,n,i),c=function(e){var n=String(e),a=Boolean(t.hasOwnProperty(n)&&r(t[n])),i=n.lastIndexOf(".");for(;!a&&-1!==i;)n=n.substr(0,i),i=n.lastIndexOf("."),a=Boolean(t.hasOwnProperty(n)&&r(t[n]));return a}(e);return!!c&&(!0===a?o():setTimeout(o,0),!0)}e.publish=function(t,n){return o(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return o(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,t.hasOwnProperty(e)||(t[e]={});var a="uid_"+String(++n);return t[e][a]=r,a},e.subscribeOnce=function(t,n){var r=e.subscribe(t,function(){e.unsubscribe(r),n.apply(this,arguments)});return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,r=0;for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&r++;return r},e.getSubscriptions=function(e){var n,r=[];for(n in t)t.hasOwnProperty(n)&&0===n.indexOf(e)&&r.push(n);return r},e.unsubscribe=function(n){var r,a,i,s="string"==typeof n&&(t.hasOwnProperty(n)||function(e){var n;for(n in t)if(t.hasOwnProperty(n)&&0===n.indexOf(e))return!0;return!1}(n)),o=!s&&"string"==typeof n,c="function"==typeof n,l=!1;if(!s){for(r in t)if(t.hasOwnProperty(r)){if(a=t[r],o&&a[n]){delete a[n],l=n;break}if(c)for(i in a)a.hasOwnProperty(i)&&a[i]===n&&(delete a[i],l=!0)}return l}e.clearSubscriptions(n)}}(a),"function"==typeof i&&i.amd?i(function(){return a}):(void 0!==e&&e.exports&&(t=e.exports=a),t.PubSub=a,e.exports=t=a)}("object"==typeof window&&window||L)}),_=(J.PubSub,function(e,t){return function n(){null==t&&(t=e.length);var r=[].slice.call(arguments);return r.length>=t?e.apply(this,r):function(){return n.apply(this,r.concat([].slice.call(arguments)))}}});const z=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(H)},B=(e,t,n,r)=>{if(0===e.length)return n;if(e.length>1){const a=e.shift();return{...t,[a]:B(e,Q(t,a,r),n,G(a,r))}}if(Array.isArray(t)){const r=[...t];return r[Z(t,e[0])]=n,r}return"object"==typeof t&&null!==t?{...t,[e[0]]:n}:Q(t,e[0],r)},F=(e,t,n,r)=>{if(0!==e.length)if(1!==e.length||Y(t)){const a=e.shift();F(e,Q(t,a,r),n,G(a,r))}else{t[Z(t,e[0])]=n}},K=(e,t,n)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=Q(t,r,n);return{...t,[r]:K(e,a,G(r,n))}}if(Array.isArray(t))return t.filter((t,n)=>n!=e[0]);if("object"==typeof t&&null!==t){const{[e[0]]:n,...r}=t;return r}return Q(t,e[0],n)}},U=(e,t,n)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=Q(t,r,n);U(e,a,G(r,n))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:Q(t,e[0],n)},G=_((e,t)=>t+"/"+W(e)),W=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),H=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),Z=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,Q=(e,t,n="")=>{if(void 0===e)throw TypeError(`Value at '${n}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${n}' is null and does not have property '${t}'`);if(Y(e))throw TypeError(`Value at '${n}' is a ${typeof e} and does not have property '${t}'`);return e[Z(e,t)]},Y=e=>null===e||"object"!=typeof e;var ee={nil:"",append:G,get:(e,t)=>{const n=z(e),r=e=>n.reduce(([e,t],n)=>[Q(e,n,t),G(n,t)],[e,""])[0];return void 0===t?r:r(t)},set:(e,t,n)=>{const r=z(e),a=_((e,t)=>B(r,e,t,""));return void 0===t?a:a(t,n)},assign:(e,t,n)=>{const r=z(e),a=_((e,t)=>F(r,e,t,""));return void 0===t?a:a(t,n)},unset:(e,t)=>{const n=z(e),r=e=>K(n,e,"");return void 0===t?r:r(t)},delete:(e,t)=>{const n=z(e),r=e=>U(n,e,"");return void 0===t?r:r(t)}};var te={internalValue:Symbol("$__value"),isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{internalValue:ne}=te,re=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),ae=e=>e.value&&e.value[ne]?e.value[ne]:e.value,ie=(e,t)=>Object.freeze({...t,pointer:ee.append(e,t.pointer),value:ae(t)[e]}),se=_((e,t)=>ae(t).map((n,r,a,i)=>e(ie(r,t),r,a,i))),oe=_((e,t)=>ae(t).map((e,n,r,a)=>ie(n,t)).filter((t,n,r,a)=>e(t,n,r,a))),ce=_((e,t,n)=>ae(n).reduce((t,r,a)=>e(t,ie(a,n),a),t)),le=_((e,t)=>ae(t).every((n,r,a,i)=>e(ie(r,t),r,a,i))),ue=_((e,t)=>ae(t).some((n,r,a,i)=>e(ie(r,t),r,a,i)));var me={cons:(e,t="")=>Object.freeze({...re,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:ae,step:ie,entries:e=>Object.keys(ae(e)).map(t=>[t,ie(t,e)]),map:se,filter:oe,reduce:ce,every:le,some:ue},pe=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,fe=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,de=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,he=/\\([\u000b\u0020-\u00ff])/g,ve=/([\\"])/g,ye=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function ge(e){var t=String(e);if(de.test(t))return t;if(t.length>0&&!fe.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(ve,"\\$1")+'"'}function $e(e){this.parameters=Object.create(null),this.type=e}var be={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,n=e.type;if(!n||!ye.test(n))throw new TypeError("invalid type");var r=n;if(t&&"object"==typeof t)for(var a,i=Object.keys(t).sort(),s=0;s<i.length;s++){if(a=i[s],!de.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+ge(t[a])}return r},parse:function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var n=t.indexOf(";"),r=-1!==n?t.substr(0,n).trim():t.trim();if(!ye.test(r))throw new TypeError("invalid media type");var a=new $e(r.toLowerCase());if(-1!==n){var i,s,o;for(pe.lastIndex=n;s=pe.exec(t);){if(s.index!==n)throw new TypeError("invalid parameter format");n+=s[0].length,i=s[1].toLowerCase(),'"'===(o=s[2])[0]&&(o=o.substr(1,o.length-2).replace(he,"$1")),a.parameters[i]=o}if(n!==t.length)throw new TypeError("invalid parameter format")}return a}},xe=async e=>Object.entries(await e),we=_(async(e,t)=>(await t).map(e)),Ie=_(async(e,t,n)=>(await n).reduce(async(t,n)=>e(await t,n),t)),je=_(async(e,t,n={})=>Ie(async(t,n)=>await e(n)?t.concat([n]):t,[],t,n)),Oe=_(async(e,t)=>{const n=await we(e,t);return(await Promise.all(n)).some(e=>e)}),Ee=_(async(e,t)=>{const n=await we(e,t);return(await Promise.all(n)).every(e=>e)}),Se=_((e,t)=>e.reduce(async(e,t)=>t(await e),t)),Ae={entries:xe,map:we,filter:je,reduce:Ie,some:Oe,every:Ee,pipeline:Se,all:e=>Promise.all(e),allValues:e=>Se([xe,Ie(async(e,[t,n])=>(e[t]=await n,e),{})],e)},Pe=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const n=function(e){const t={host:"",path:"",query:"",protocol:""};let n=e,r=e.indexOf("//");t.protocol=n.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),s=e.indexOf("#");-1!==s&&(n=n.substring(0,s));if(-1!==i){const e=n.substring(i);t.query=e,n=n.substring(0,i)}if(-1!==a){const e=n.substring(0,a);t.host=e,n=n.substring(a),t.path=n}else t.host=n;return t}(e),r=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(Te.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let n=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=n.substring(a);t.hash=e,n=n.substring(0,a)}if(-1!==r){const e=n.substring(r);t.query=e,n=n.substring(0,r)}return t.path=n,t}(t);if(!n.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=n.protocol+r.href),function(e){const t=e.indexOf("//")+2,n=!e.includes("/",t),r=!e.includes("?",t),a=!e.includes("#",t);return n&&r&&a}(r.href)?ke(r.href):r.href;if(r.absolutePath){const{path:e,query:t,hash:a}=r;return n.host+Ne(e)+t+a}if(r.relativePath){const{path:e,query:t,hash:a}=r;let i,s=n.path,o=n.host;return 0===e.length?i=s:(s=s.substring(0,s.lastIndexOf("/")),i=Ne(s+"/"+e)),o+=""!==i||t||a?i+t+a:"/"}{const{host:e,path:t,query:a}=n;return t||a?e+t+a+r.hash:ke(e)}};function ke(e){return e+("/"===e[e.length-1]?"":"/")}function Ne(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let n=[];return t.forEach((e,r)=>{"."!==e&&(".."===e?n.pop():""===e&&r!==t.length-1||n.push(e))}),"/"+n.join("/")}const Te=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");var qe=fetch;const{internalValue:Re,isObject:Ce,splitUrl:Me}=te,De=Symbol("$__jref"),Ve=Symbol("$__dynamicJref"),Le={},Xe={},Je=(e,t)=>{const n=e in Xe?Xe[e]:e;if(n in Le)return Le[n][t]},_e={},ze={},Be=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=Me(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=Je(r,"idToken"),i=Me(t)[0];if(!i&&!Me(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=He(i,e[a]||""),o=Me(s)[0];let c;i&&(ze[i]=o),Je(r,"vocabulary")&&Ce(e)&&"$vocabulary"in e?(Xe[o]=r,c=e.$vocabulary,delete e.$vocabulary):c=o===r?{[r]:!0}:{};const l={},u={};_e[o]={id:o,schemaVersion:r,schema:Fe(e,o,r,ee.nil,l,u),anchors:l,recursiveAnchors:u,vocabulary:c,validated:!1}},Fe=(e,t,n,r,a,i)=>{if(Ce(e)){const s=Je(n,"idToken"),o=Je(n,"anchorToken");if("string"==typeof e[s]){const r=e[s],a=He(t,r),[i,c]=Me(a);if(delete e[s],c&&s===o&&(e[o]=o!==s?encodeURI(c):`#${encodeURI(c)}`),i!==t)return Be(e,He(t,i),n),{[De]:r}}const c=Je(n,"dynamicAnchorToken");"string"==typeof e[c]&&(i[`#${e[c]}`]=t,e[o]=e[c],delete e[c]);const l=Je(n,"recursiveAnchorToken");if(r===ee.nil&&!0===e[l]&&(i["#"]=t,delete e[l]),"string"==typeof e[o]){const t=o!==s?e[o]:e[o].slice(1);a[t]=r,delete e[o]}const u=Je(n,"jrefToken");if("string"==typeof e[u])return{[De]:e[u],[Re]:e};e=Object.entries(e).reduce((e,[s,o])=>(e[s]=Fe(o,t,n,ee.append(s,r),a,i),e),{});const m=Je(n,"jsrefToken");"string"==typeof e[m]&&(e[m]={[De]:e[m],[Re]:e[m]});const p=Je(n,"dynamicJsrefToken");return"string"==typeof e[p]&&(e[p]={[Ve]:e[p],[Re]:e[p]}),e}return Array.isArray(e)?e.map((e,s)=>Fe(e,t,n,ee.append(s,r),a,i)):e},Ke=e=>_e[ze[e]]||_e[e],Ue=Object.freeze({id:"",schemaVersion:void 0,pointer:"",schema:void 0,recursiveAnchors:{}}),Ge=async(e,t=Ue,n=!1)=>{const r=n&&t.recursiveAnchors[e]?t.recursiveAnchors[e]:Ye(t),a=He(r,e),[i,s]=Me(a);if(!(e=>e in _e||e in ze)(i)){const e=await qe(i,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${i}`);if(e.headers.has("content-type")){const t=be.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${i} is not a schema. Found a document with media type: ${t}`)}Be(await e.json(),i)}const o=Ke(i),c=s&&"/"!==s[0]?Qe(o,s):s,l=Object.freeze({id:o.id,schemaVersion:o.schemaVersion,vocabulary:o.vocabulary,pointer:c,schema:o.schema,value:ee.get(c,o.schema),recursiveAnchors:{...o.recursiveAnchors,...t.recursiveAnchors},validated:o.validated});return We(l)},We=e=>Ce(e.value)&&De in e.value?Ge(e.value[De],e):Ce(e.value)&&Ve in e.value?Ge(e.value[Ve],e,!0):e,He=(e,t)=>{const n=Pe(e,t),r=Me(e)[0];if(r&&"file"===Ze(n)&&"file"!==Ze(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},Ze=e=>{const t=e.match(/^(.+):\/\//);return t?t[1]:""},Qe=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},Ye=e=>`${e.id}#${encodeURI(e.pointer)}`,et=e=>e.value&&e.value[Re]?e.value[Re]:e.value,tt=(e,t)=>{const n=Ke(t.id),r=Object.freeze({id:t.id,schemaVersion:t.schemaVersion,vocabulary:t.vocabulary,pointer:ee.append(e,t.pointer),schema:n.schema,value:et(t)[e],recursiveAnchors:t.recursiveAnchors,validated:n.validated});return We(r)},nt=_((e,t)=>Ae.pipeline([et,Ae.map(async(n,r)=>e(await tt(r,t),r)),Ae.all],t));var rt={setConfig:(e,t,n)=>{Le[e]||(Le[e]={}),Le[e][t]=n},getConfig:Je,add:Be,get:Ge,markValidated:e=>{_e[e].validated=!0},uri:Ye,value:et,has:(e,t)=>e in et(t),step:tt,entries:e=>Ae.pipeline([et,Object.keys,Ae.map(async t=>[t,await tt(t,e)]),Ae.all],e),map:nt};var at=class extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}};const it="FLAG",st="BASIC",ot="DETAILED",ct="VERBOSE";let lt=ot,ut=!0;const mt=(e,t)=>(n,r=it)=>{if(![it,st,ot,ct].includes(r))throw Error(`The '${r}' error format is not supported`);let a=[];const i=J.subscribe("result",pt(r,a));return xt(t,n,e),J.unsubscribe(i),a[0]},pt=(e,t)=>{const n=[];return(r,a)=>{const i={...a,errors:[]};for(;n.length>0&&ft(n[n.length-1],i);){const t=n.pop();let r=[];if(e===st&&(r=t.errors,delete t.errors),i.errors.unshift(t,...r),dt(i))break}(e===ct||e!==it&&!i.valid)&&n.push(i),t[0]=i}},ft=(e,t)=>e.instanceLocation.startsWith(t.instanceLocation)&&(e.absoluteKeywordLocation.startsWith(t.absoluteKeywordLocation)||dt(e)),dt=e=>e.keyword.endsWith("#$ref")||e.keyword.endsWith("#$recursiveRef"),ht={},vt=e=>ht[e],yt=e=>e in ht,gt={},$t={},bt=async(e,t)=>{if(!yt(`${e.schemaVersion}#validate`)){const t=await rt.get(e.schemaVersion);(rt.getConfig(t.id,"mandatoryVocabularies")||[]).forEach(e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)}),Object.entries(t.vocabulary).forEach(([e,n])=>{if(e in gt)Object.entries(gt[e]).forEach(([e,n])=>{((e,t)=>{ht[e]={collectEvaluatedItems:(e,n,r)=>t.interpret(e,n,r)&&0,collectEvaluatedProperties:(e,n,r)=>t.interpret(e,n,r)&&[],...t}})(`${t.id}#${e}`,n)});else if(n)throw Error(`Missing required vocabulary: ${e}`)})}if(ut&&!e.validated){if(rt.markValidated(e.id),!(e.schemaVersion in $t)){const t=await rt.get(e.schemaVersion),n={},r=await bt(t,n);$t[t.id]=mt(n,r)}const t=me.cons(e.schema,e.id),n=$t[e.schemaVersion](t,lt);if(!n.valid)throw new at(n)}return await vt(`${e.schemaVersion}#validate`).compile(e,t),rt.uri(e)},xt=(e,t,n)=>{const[r]=n[e];return vt(r).interpret(e,t,n)};var wt={validate:async(e,t,n)=>{const r={},a=await bt(e,r),i=(e,t=it)=>mt(r,a)(me.cons(e),t);return void 0===t?i:i(t,n)},setMetaOutputFormat:e=>{lt=e},setShouldMetaValidate:e=>{ut=e},FLAG:it,BASIC:st,DETAILED:ot,VERBOSE:ct,getKeyword:vt,hasKeyword:yt,defineVocabulary:(e,t)=>{gt[e]=t},compileSchema:bt,interpretSchema:xt,collectEvaluatedProperties:(e,t,n,r)=>{const[a]=n[e];return vt(a).collectEvaluatedProperties(e,t,n,r)},collectEvaluatedItems:(e,t,n,r)=>{const[a]=n[e];return vt(a).collectEvaluatedItems(e,t,n,r)}};var It={compile:async(e,t)=>{const n=rt.uri(e);if(!(n in t)){t[n]=!1;const r=rt.value(e);t[n]=[`${e.schemaVersion}#validate`,rt.uri(e),"boolean"==typeof r?r:await Ae.pipeline([rt.entries,Ae.map(([t,n])=>[`${e.schemaVersion}#${t}`,n]),Ae.filter(([t])=>wt.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`),Ae.map(async([n,r])=>{const a=await wt.getKeyword(n).compile(r,t,e);return[n,rt.uri(r),a]}),Ae.all],e)]}},interpret:(e,t,n)=>{const[r,a,i]=n[e],s="boolean"==typeof i?i:i.every(([e,r,a])=>{const i=wt.getKeyword(e).interpret(a,t,n);return J.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:me.uri(t),valid:i}),i});return J.publishSync("result",{keyword:r,absoluteKeywordLocation:a,instanceLocation:me.uri(t),valid:s}),s},collectEvaluatedProperties:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter(([e])=>!r||!e.endsWith("#unevaluatedProperties")).reduce((e,[r,,a])=>{const i=e&&wt.getKeyword(r).collectEvaluatedProperties(a,t,n);return i&&e.concat(i)},[])},collectEvaluatedItems:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter(([e])=>!r||!e.endsWith("#unevaluatedItems")).reduce((e,[r,,a])=>{const i=!1!==e&&wt.getKeyword(r).collectEvaluatedItems(a,t,n);return!1!==i&&Math.max(e,i)},0)}},jt={Core:wt,Schema:rt,Instance:me,Keywords:{metaData:{compile:()=>void 0,interpret:()=>!0},validate:It}};const{Core:Ot,Schema:Et,Instance:St}=jt;var At={compile:async(e,t,n)=>{const r=await Et.step("items",n),a=Et.value(r),i=Array.isArray(a)?a.length:Number.MAX_SAFE_INTEGER,s=Et.value(e);return"boolean"==typeof s?[i,s]:[i,await Ot.compileSchema(e,t)]},interpret:([e,t],n,r)=>!Array.isArray(St.value(n))||("string"==typeof t?St.every((n,a)=>a<e||Ot.interpretSchema(t,n,r),n):St.every((n,r)=>r<e||t,n))};const{Core:Pt,Schema:kt,Instance:Nt}=jt,Tt=([e,t],n,r)=>!Array.isArray(Nt.value(n))||Nt.every((n,a)=>a<e||Pt.interpretSchema(t,n,r),n);var qt={compile:async(e,t,n)=>{const r=await kt.step("items",n),a=kt.value(r);return[Array.isArray(a)?a.length:Number.MAX_SAFE_INTEGER,await Pt.compileSchema(e,t)]},interpret:Tt,collectEvaluatedItems:(e,t,n)=>Tt(e,t,n)&&Number.MAX_SAFE_INTEGER};var Rt={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&")};const{Core:Ct,Schema:Mt,Instance:Dt}=jt,{isObject:Vt}=Rt;var Lt={compile:async(e,t,n)=>{const r=await Mt.step("properties",n),a=Mt.value(r)||{},i=Object.keys(a),s=await Mt.step("patternProperties",n),o=Mt.value(s)||{},c=Object.keys(o).map(e=>new RegExp(e)),l=Mt.value(e);return"boolean"==typeof l?[i,c,l]:[i,c,await Ct.compileSchema(e,t)]},interpret:([e,t,n],r,a)=>{const i=Dt.value(r);if(!Vt(i))return!0;const s=Dt.entries(r).filter(([n])=>!e.includes(n)&&!t.some(e=>e.test(n)));return"string"==typeof n?s.every(([,e])=>Ct.interpretSchema(n,e,a)):0===s.length||n}};const{Core:Xt,Schema:Jt,Instance:_t}=jt,{isObject:zt}=Rt,Bt=([e,t,n],r,a)=>{const i=_t.value(r);return!zt(i)||_t.entries(r).filter(([n])=>!e.includes(n)&&!t.some(e=>e.test(n))).every(([,e])=>Xt.interpretSchema(n,e,a))};var Ft={compile:async(e,t,n)=>{const r=await Jt.step("properties",n),a=Jt.value(r)||{},i=Object.keys(a),s=await Jt.step("patternProperties",n),o=Jt.value(s)||{};return[i,Object.keys(o).map(e=>new RegExp(e)),await Xt.compileSchema(e,t)]},interpret:Bt,collectEvaluatedProperties:(e,t,n)=>Bt(e,t,n)&&[new RegExp("")]};const{Core:Kt,Schema:Ut}=jt;var Gt={compile:(e,t)=>Ae.pipeline([Ut.map(async e=>Kt.compileSchema(await e,t)),Ae.all],e),interpret:(e,t,n)=>e.every(e=>Kt.interpretSchema(e,t,n)),collectEvaluatedProperties:(e,t,n)=>e.reduce((e,r)=>{const a=e&&Kt.collectEvaluatedProperties(r,t,n);return a&&e.concat(a)},[]),collectEvaluatedItems:(e,t,n)=>e.reduce((e,r)=>{const a=!1!==e&&Kt.collectEvaluatedItems(r,t,n);return!1!==a&&Math.max(e,a)},0)};const{Core:Wt,Schema:Ht}=jt;var Zt={compile:(e,t)=>Ae.pipeline([Ht.map(async e=>Wt.compileSchema(await e,t)),Ae.all],e),interpret:(e,t,n)=>e.some(e=>Wt.interpretSchema(e,t,n)),collectEvaluatedProperties:(e,t,n)=>e.reduce((e,r)=>{const a=Wt.collectEvaluatedProperties(r,t,n);return a?(e||[]).concat(a):e},!1),collectEvaluatedItems:(e,t,n)=>e.reduce((e,r)=>{const a=Wt.collectEvaluatedItems(r,t,n);return!1!==a?Math.max(e,a):e},!1)},Qt=Object.keys,Yt=JSON.stringify;var en=function(e){return""+function e(t,n){var r,a,i,s,o,c,l;if("string"==(l=typeof t))return Yt(t);if(!0===t)return"true";if(!1===t)return"false";if(null===t)return"null";if(t instanceof Array){for(i="[",a=t.length-1,r=0;r<a;r++)i+=e(t[r],!1)+",";return a>-1&&(i+=e(t[r],!1)),i+"]"}if(t instanceof Object){if("function"==typeof t.toJSON)return e(t.toJSON(),n);for(a=(s=Qt(t).sort()).length,i="",r=0;r<a;)void 0!==(c=e(t[o=s[r]],!0))&&(r&&""!==i&&(i+=","),i+=Yt(o)+":"+c),r++;return"{"+i+"}"}switch(l){case"function":case"undefined":return n?void 0:null;default:return isFinite(t)?t:null}}(e,!1)};const{Schema:tn,Instance:nn}=jt;var rn={compile:e=>en(tn.value(e)),interpret:(e,t)=>en(nn.value(t))===e};const{Core:an,Instance:sn}=jt;var on={compile:(e,t)=>an.compileSchema(e,t),interpret:(e,t,n)=>{const r=sn.value(t);return!Array.isArray(r)||sn.some(t=>an.interpretSchema(e,t,n),t)}};const{Core:cn,Schema:ln,Instance:un}=jt;var mn={compile:async(e,t,n)=>{const r=await cn.compileSchema(e,t),a=await ln.step("minContains",n),i=ln.value(a),s=void 0===i?1:i,o=await ln.step("maxContains",n),c=ln.value(o);return{contains:r,minContains:s,maxContains:void 0===c?Number.MAX_SAFE_INTEGER:c}},interpret:({contains:e,minContains:t,maxContains:n},r,a)=>{const i=un.value(r);if(!Array.isArray(i))return!0;const s=un.reduce((t,n)=>cn.interpretSchema(e,n,a)?t+1:t,0,r);return s>=t&&s<=n}};const{Core:pn,Schema:fn}=jt;var dn={compile:async(e,t)=>{await Ae.pipeline([fn.entries,Ae.map(([,e])=>pn.compileSchema(e,t)),Ae.all],e)},interpret:()=>!0};const{Core:hn,Schema:vn,Instance:yn}=jt,{isObject:gn}=Rt;var $n={compile:(e,t)=>Ae.pipeline([vn.entries,Ae.map(async([e,n])=>{const r=vn.value(n);return[e,Array.isArray(r)?r:await hn.compileSchema(n,t)]}),Ae.all],e),interpret:(e,t,n)=>{const r=yn.value(t);return!gn(r)||e.every(([e,a])=>!(e in r)||(Array.isArray(a)?a.every(e=>e in r):hn.interpretSchema(a,t,n)))}};const{Schema:bn,Instance:xn}=jt,{isObject:wn}=Rt;var In={compile:e=>Ae.pipeline([bn.entries,Ae.map(([e,t])=>[e,bn.value(t)]),Ae.all],e),interpret:(e,t)=>{const n=xn.value(t);return!wn(n)||e.every(([e,t])=>!(e in n)||t.every(e=>e in n))}};const{Core:jn,Schema:On,Instance:En}=jt,{isObject:Sn}=Rt;var An={compile:(e,t)=>Ae.pipeline([On.entries,Ae.map(async([e,n])=>[e,await jn.compileSchema(n,t)]),Ae.all],e),interpret:(e,t,n)=>{const r=En.value(t);return!Sn(r)||e.every(([e,a])=>!(e in r)||jn.interpretSchema(a,t,n))},collectEvaluatedProperties:(e,t,n)=>{const r=En.value(t);return e.reduce((e,[a,i])=>{if(!(e&&a in r))return e;const s=jn.collectEvaluatedProperties(i,t,n);return s&&e.concat(s)},[])}};const{Schema:Pn,Instance:kn}=jt;var Nn={compile:e=>Pn.value(e).map(en),interpret:(e,t)=>e.some(e=>en(kn.value(t))===e)};const{Schema:Tn,Instance:qn}=jt;var Rn={compile:async e=>Tn.value(e),interpret:(e,t)=>{const n=qn.value(t);return"number"!=typeof n||n<e}};const{Schema:Cn,Instance:Mn}=jt;var Dn={compile:async e=>Cn.value(e),interpret:(e,t)=>{const n=Mn.value(t);return"number"!=typeof n||n>e}};const{Schema:Vn,Instance:Ln}=jt;var Xn={compile:async e=>Vn.value(e),interpret:(e,t)=>{const n=Ln.value(t);return"number"!=typeof n||"boolean"==typeof e||n<e}};const{Schema:Jn,Instance:_n}=jt;var zn={compile:async e=>Jn.value(e),interpret:(e,t)=>{const n=_n.value(t);return"number"!=typeof n||"boolean"==typeof e||n>e}};const{Core:Bn,Schema:Fn}=jt;var Kn={compile:async(e,t,n)=>{const r={},a=Fn.value(n);if(r.if=await Bn.compileSchema(e,t),"then"in a){const e=await Fn.step("then",n);r.then=await Bn.compileSchema(e,t)}if("else"in a){const e=await Fn.step("else",n);r.else=await Bn.compileSchema(e,t)}return r},interpret:(e,t,n)=>Bn.interpretSchema(e.if,t,n)?!("then"in e)||Bn.interpretSchema(e.then,t,n):!("else"in e)||Bn.interpretSchema(e.else,t,n),collectEvaluatedProperties:(e,t,n)=>{const r=Bn.collectEvaluatedProperties(e.if,t,n),a=r?"then":"else";if(e[a]){const i=Bn.collectEvaluatedProperties(e[a],t,n);return i&&(r||[]).concat(i)}return r||[]},collectEvaluatedItems:(e,t,n)=>{const r=Bn.collectEvaluatedItems(e.if,t,n),a="number"==typeof r?"then":"else";if(e[a]){const i=Bn.collectEvaluatedItems(e[a],t,n);return!1!==i&&Math.max(r,i)}return r||0}};const{Core:Un,Schema:Gn,Instance:Wn}=jt,Hn=(e,t,n)=>{const r=Wn.value(t);return!Array.isArray(r)||("string"==typeof e?Wn.every(t=>Un.interpretSchema(e,t,n),t):Wn.every((t,r)=>!(r in e)||Un.interpretSchema(e[r],t,n),t))};var Zn={compile:(e,t)=>Array.isArray(Gn.value(e))?Ae.pipeline([Gn.map(e=>Un.compileSchema(e,t)),Ae.all],e):Un.compileSchema(e,t),interpret:Hn,collectEvaluatedItems:(e,t,n)=>Hn(e,t,n)&&("string"==typeof e?Number.MAX_SAFE_INTEGER:e.length)};const{Schema:Qn,Instance:Yn}=jt;var er={compile:e=>Qn.value(e),interpret:(e,t)=>{const n=Yn.value(t);return!Array.isArray(n)||n.length<=e}};const{Schema:tr,Instance:nr}=jt;var rr={compile:e=>tr.value(e),interpret:(e,t)=>{const n=nr.value(t);return"string"!=typeof n||n.length<=e}};const{Schema:ar,Instance:ir}=jt;var sr={compile:e=>ar.value(e),interpret:(e,t)=>{const n=ir.value(t);return"string"!=typeof n||[...n].length<=e}};const{Schema:or,Instance:cr}=jt,{isObject:lr}=Rt;var ur={compile:e=>or.value(e),interpret:(e,t)=>{const n=cr.value(t);return!lr(n)||Object.keys(n).length<=e}};const{Schema:mr,Instance:pr}=jt;var fr={compile:async(e,t,n)=>{const r=await mr.step("exclusiveMaximum",n),a=mr.value(r);return[mr.value(e),a]},interpret:([e,t],n)=>{const r=pr.value(n);return"number"!=typeof r||(t?r<e:r<=e)}};const{Schema:dr,Instance:hr}=jt;var vr={compile:async(e,t,n)=>{const r=await dr.step("exclusiveMaximum",n),a=dr.value(r),i="boolean"==typeof a&&a;return[dr.value(e),i]},interpret:([e,t],n)=>{const r=hr.value(n);return"number"!=typeof r||(t?r<e:r<=e)}};const{Schema:yr,Instance:gr}=jt;var $r={compile:async e=>yr.value(e),interpret:(e,t)=>{const n=gr.value(t);return"number"!=typeof n||n<=e}};const{Schema:br,Instance:xr}=jt;var wr={compile:e=>br.value(e),interpret:(e,t)=>{const n=xr.value(t);return!Array.isArray(n)||n.length>=e}};const{Schema:Ir,Instance:jr}=jt;var Or={compile:e=>Ir.value(e),interpret:(e,t)=>{const n=jr.value(t);return"string"!=typeof n||n.length>=e}};const{Schema:Er,Instance:Sr}=jt;var Ar={compile:e=>Er.value(e),interpret:(e,t)=>{const n=Sr.value(t);return"string"!=typeof n||[...n].length>=e}};const{Schema:Pr,Instance:kr}=jt,{isObject:Nr}=Rt;var Tr={compile:e=>Pr.value(e),interpret:(e,t)=>{const n=kr.value(t);return!Nr(n)||Object.keys(n).length>=e}};const{Schema:qr,Instance:Rr}=jt;var Cr={compile:async(e,t,n)=>{const r=await qr.step("exclusiveMinimum",n),a=qr.value(r);return[qr.value(e),a]},interpret:([e,t],n)=>{const r=Rr.value(n);return"number"!=typeof r||(t?r>e:r>=e)}};const{Schema:Mr,Instance:Dr}=jt;var Vr={compile:async(e,t,n)=>{const r=await Mr.step("exclusiveMinimum",n),a=Mr.value(r),i="boolean"==typeof a&&a;return[Mr.value(e),i]},interpret:([e,t],n)=>{const r=Dr.value(n);return"number"!=typeof r||(t?r>e:r>=e)}};const{Schema:Lr,Instance:Xr}=jt;var Jr={compile:async e=>Lr.value(e),interpret:(e,t)=>{const n=Xr.value(t);return"number"!=typeof n||n>=e}};const{Schema:_r,Instance:zr}=jt,Br=(e,t)=>Math.abs(e-t)<Number.EPSILON;var Fr={compile:e=>_r.value(e),interpret:(e,t)=>{const n=zr.value(t);if("number"!=typeof n)return!0;const r=n%e;return Br(0,r)||Br(e,r)}};const{Core:Kr}=jt;var Ur={compile:Kr.compileSchema,interpret:(e,t,n)=>!Kr.interpretSchema(e,t,n)};const{Core:Gr,Schema:Wr}=jt;var Hr={compile:(e,t)=>Ae.pipeline([Wr.map(async e=>Gr.compileSchema(await e,t)),Ae.all],e),interpret:(e,t,n)=>{let r=0;for(const a of e)if(Gr.interpretSchema(a,t,n)&&r++,r>1)break;return 1===r},collectEvaluatedProperties:(e,t,n)=>{let r=0;return e.reduce((e,a)=>{if(r>1)return!1;const i=Gr.collectEvaluatedProperties(a,t,n);return i?0==r++&&i:e},!1)},collectEvaluatedItems:(e,t,n)=>{let r=0;return e.reduce((e,a)=>{if(r>1)return!1;const i=Gr.collectEvaluatedItems(a,t,n);return"number"==typeof i?0==r++&&i:e},!1)}};const{Schema:Zr,Instance:Qr}=jt;var Yr={compile:e=>new RegExp(Zr.value(e),"u"),interpret:(e,t)=>{const n=Qr.value(t);return"string"!=typeof n||e.test(n)}};const{Core:ea,Schema:ta,Instance:na}=jt,{isObject:ra}=Rt,aa=(e,t,n)=>{const r=na.value(t);return!ra(r)||e.every(([e,r])=>na.entries(t).filter(([t])=>e.test(t)).every(([,e])=>ea.interpretSchema(r,e,n)))};var ia={compile:(e,t)=>Ae.pipeline([ta.entries,Ae.map(async([e,n])=>[new RegExp(e,"u"),await ea.compileSchema(n,t)]),Ae.all],e),interpret:aa,collectEvaluatedProperties:(e,t,n)=>aa(e,t,n)&&e.map(([e])=>e)};const{Core:sa,Schema:oa,Instance:ca}=jt,{isObject:la,escapeRegExp:ua}=Rt,ma=(e,t,n)=>!la(ca.value(t))||ca.entries(t).filter(([t])=>t in e).every(([t,r])=>sa.interpretSchema(e[t],r,n));var pa={compile:(e,t)=>Ae.pipeline([oa.entries,Ae.reduce(async(e,[n,r])=>(e[n]=await sa.compileSchema(r,t),e),{})],e),interpret:ma,collectEvaluatedProperties:(e,t,n)=>ma(e,t,n)&&Object.keys(e).map(e=>new RegExp(`^${ua(e)}$`))};const{Core:fa,Instance:da}=jt,{isObject:ha}=Rt;var va={compile:(e,t)=>fa.compileSchema(e,t),interpret:(e,t,n)=>{const r=da.value(t);return!ha(r)||Object.keys(r).every(t=>fa.interpretSchema(e,da.cons(t),n))}};const{Core:ya}=jt;var ga={compile:ya.compileSchema,interpret:ya.interpretSchema,collectEvaluatedProperties:ya.collectEvaluatedProperties,collectEvaluatedItems:ya.collectEvaluatedItems};const{Core:$a}=jt;var ba={compile:$a.compileSchema,interpret:$a.interpretSchema,collectEvaluatedProperties:$a.collectEvaluatedProperties,collectEvaluatedItems:$a.collectEvaluatedItems};const{Schema:xa,Instance:wa}=jt,{isObject:Ia}=Rt;var ja={compile:e=>xa.value(e),interpret:(e,t)=>{const n=wa.value(t);return!Ia(n)||e.every(e=>e in n)}};const{Schema:Oa,Instance:Ea}=jt,{isObject:Sa}=Rt,Aa={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:Sa,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e};var Pa={compile:e=>Oa.value(e),interpret:(e,t)=>{const n=Ea.value(t);return"string"==typeof e?Aa[e](n):e.some(e=>Aa[e](n))}};const{Core:ka,Schema:Na,Instance:Ta}=jt,qa=([e,t],n,r)=>{const a=Ta.value(n);if(!Array.isArray(a))return!0;const i=ka.collectEvaluatedItems(e,n,r,!0);return!1===i||Ta.filter((e,t)=>t>=i,n).every(e=>ka.interpretSchema(t,e,r))};var Ra={compile:async(e,t,n)=>[Na.uri(n),await ka.compileSchema(e,t)],interpret:qa,collectEvaluatedItems:(e,t,n)=>qa(e,t,n)&&Number.MAX_SAFE_INTEGER};const{Core:Ca,Schema:Ma,Instance:Da}=jt,{isObject:Va}=Rt,La=([e,t],n,r)=>{const a=Da.value(n);if(!Va(a))return!0;const i=Ca.collectEvaluatedProperties(e,n,r,!0);return!i||Da.entries(n).filter(([e])=>!i.some(t=>e.match(t))).every(([,e])=>Ca.interpretSchema(t,e,r))};var Xa={compile:async(e,t,n)=>[Ma.uri(n),await Ca.compileSchema(e,t)],interpret:La,collectEvaluatedProperties:(e,t,n)=>La(e,t,n)&&[new RegExp("")]};const{Schema:Ja,Instance:_a}=jt;var za={compile:e=>Ja.value(e),interpret:(e,t)=>{const n=_a.value(t);if(!Array.isArray(n)||!1===e)return!0;const r=_a.map(e=>en(_a.value(e)),t);return new Set(r).size===r.length}};const{Keywords:Ba}=jt;var Fa={additionalItems:At,additionalItems6:qt,additionalProperties:Lt,additionalProperties6:Ft,allOf:Gt,anyOf:Zt,const:rn,contains:on,containsMinContainsMaxContains:mn,definitions:dn,dependencies:$n,dependentRequired:In,dependentSchemas:An,enum:Nn,exclusiveMaximum:Rn,exclusiveMinimum:Dn,exclusiveMaximumOas31:Xn,exclusiveMinimumOas31:zn,ifThenElse:Kn,items:Zn,maxItems:er,maxLength:rr,maxLength6:sr,maxProperties:ur,maximumExclusiveMaximum:fr,maximumExclusiveMaximumOas31:vr,maximum:$r,metaData:Ba.metaData,minItems:wr,minLength:Or,minLength6:Ar,minProperties:Tr,minimumExclusiveMinimum:Cr,minimumExclusiveMinimumOas31:Vr,minimum:Jr,multipleOf:Fr,not:Ur,oneOf:Hr,pattern:Yr,patternProperties:ia,properties:pa,propertyNames:va,$recursiveRef:ga,$ref:ba,required:ja,type:Pa,unevaluatedItems:Ra,unevaluatedProperties:Xa,uniqueItems:za,validate:Ba.validate};const{Core:Ka,Schema:Ua}=jt,Ga="http://json-schema.org/draft-04/schema";Ua.setConfig(Ga,"jrefToken","$ref"),Ua.setConfig(Ga,"idToken","id"),Ua.setConfig(Ga,"anchorToken","id"),Ua.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),Ka.defineVocabulary(Ga,{validate:Fa.validate,additionalItems:Fa.additionalItems,additionalProperties:Fa.additionalProperties,allOf:Fa.allOf,anyOf:Fa.anyOf,default:Fa.metaData,definitions:Fa.definitions,dependencies:Fa.dependencies,description:Fa.metaData,enum:Fa.enum,format:Fa.metaData,items:Fa.items,maxItems:Fa.maxItems,maxLength:Fa.maxLength,maxProperties:Fa.maxProperties,maximum:Fa.maximumExclusiveMaximum,minItems:Fa.minItems,minLength:Fa.minLength,minProperties:Fa.minProperties,minimum:Fa.minimumExclusiveMinimum,multipleOf:Fa.multipleOf,not:Fa.not,oneOf:Fa.oneOf,pattern:Fa.pattern,patternProperties:Fa.patternProperties,properties:Fa.properties,required:Fa.required,title:Fa.metaData,type:Fa.type,uniqueItems:Fa.uniqueItems});const Wa="http://json-schema.org/draft-04/hyper-schema";Ua.setConfig(Wa,"jrefToken","$ref"),Ua.setConfig(Wa,"idToken","id"),Ua.setConfig(Wa,"anchorToken","id"),Ua.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-04/hyper-schema#",\n    "id": "http://json-schema.org/draft-04/hyper-schema#",\n    "title": "JSON Hyper-Schema",\n    "allOf": [\n        {"$ref": "http://json-schema.org/draft-04/schema#"}\n    ],\n    "properties": {\n        "additionalItems": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "additionalProperties": {\n            "anyOf": [\n                {"type": "boolean"},\n                {"$ref": "#"}\n            ]\n        },\n        "dependencies": {\n            "additionalProperties": {\n                "anyOf": [\n                    {"$ref": "#"},\n                    {"type": "array"}\n                ]\n            }\n        },\n        "items": {\n            "anyOf": [\n                {"$ref": "#"},\n                {"$ref": "#/definitions/schemaArray"}\n            ]\n        },\n        "definitions": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "patternProperties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "properties": {\n            "additionalProperties": {"$ref": "#"}\n        },\n        "allOf": {"$ref": "#/definitions/schemaArray"},\n        "anyOf": {"$ref": "#/definitions/schemaArray"},\n        "oneOf": {"$ref": "#/definitions/schemaArray"},\n        "not": { "$ref": "#" },\n\n        "links": {\n            "type": "array",\n            "items": {"$ref": "#/definitions/linkDescription"}\n        },\n        "fragmentResolution": {\n            "type": "string"\n        },\n        "media": {\n            "type": "object",\n            "properties": {\n                "type": {\n                    "description": "A media type, as described in RFC 2046",\n                    "type": "string"\n                },\n                "binaryEncoding": {\n                    "description": "A content encoding scheme, as described in RFC 2045",\n                    "type": "string"\n                }\n            }\n        },\n        "pathStart": {\n            "description": "Instances\' URIs must start with this value for this schema to apply to them",\n            "type": "string",\n            "format": "uri"\n        }\n    },\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "items": {"$ref": "#"}\n        },\n        "linkDescription": {\n            "title": "Link Description Object",\n            "type": "object",\n            "required": ["href", "rel"],\n            "properties": {\n                "href": {\n                    "description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",\n                    "type": "string"\n                },\n                "rel": {\n                    "description": "relation to the target resource of the link",\n                    "type": "string"\n                },\n                "title": {\n                    "description": "a title for the link",\n                    "type": "string"\n                },\n                "targetSchema": {\n                    "description": "JSON Schema describing the link target",\n                    "$ref": "#"\n                },\n                "mediaType": {\n                    "description": "media type (as defined by RFC 2046) describing the link target",\n                    "type": "string"\n                },\n                "method": {\n                    "description": "method for requesting the target of the link (e.g. for HTTP this might be \\"GET\\" or \\"DELETE\\")",\n                    "type": "string"\n                },\n                "encType": {\n                    "description": "The media type in which to submit data along with the request",\n                    "type": "string",\n                    "default": "application/json"\n                },\n                "schema": {\n                    "description": "Schema describing the data to submit along with the request",\n                    "$ref": "#"\n                }\n            }\n        },\n        "readOnly": {\n            "description": "If true, indicates that the value of this property is controlled by the server.",\n            "type": "boolean",\n            "default": false\n        }\n    },\n    "links": [\n        {\n            "rel": "self",\n            "href": "{+id}"\n        },\n        {\n            "rel": "full",\n            "href": "{+($ref)}"\n        }\n    ]\n}')),Ka.defineVocabulary(Wa,{validate:Fa.validate,additionalItems:Fa.additionalItems,additionalProperties:Fa.additionalProperties,allOf:Fa.allOf,anyOf:Fa.anyOf,default:Fa.metaData,definitions:Fa.definitions,dependencies:Fa.dependencies,description:Fa.metaData,enum:Fa.enum,format:Fa.metaData,fragmentResolution:Fa.metaData,items:Fa.items,maxItems:Fa.maxItems,minProperties:Fa.minProperties,maxProperties:Fa.maxProperties,maximum:Fa.maximumExclusiveMaximum,media:Fa.metaData,minItems:Fa.minItems,minLength:Fa.minLength,maxLength:Fa.maxLength,minimum:Fa.minimumExclusiveMinimum,multipleOf:Fa.multipleOf,links:Fa.metaData,not:Fa.not,oneOf:Fa.oneOf,pathStart:Fa.metaData,pattern:Fa.pattern,patternProperties:Fa.patternProperties,properties:Fa.properties,readOnly:Fa.metaData,required:Fa.required,title:Fa.metaData,type:Fa.type,uniqueItems:Fa.uniqueItems});const{Core:Ha,Schema:Za}=jt,Qa="http://json-schema.org/draft-06/schema";Za.setConfig(Qa,"jrefToken","$ref"),Za.setConfig(Qa,"idToken","$id"),Za.setConfig(Qa,"anchorToken","$id"),Za.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),Ha.defineVocabulary(Qa,{validate:Fa.validate,additionalItems:Fa.additionalItems6,additionalProperties:Fa.additionalProperties6,allOf:Fa.allOf,anyOf:Fa.anyOf,const:Fa.const,contains:Fa.contains,default:Fa.metaData,definitions:Fa.definitions,dependencies:Fa.dependencies,description:Fa.metaData,enum:Fa.enum,examples:Fa.metaData,exclusiveMaximum:Fa.exclusiveMaximum,exclusiveMinimum:Fa.exclusiveMinimum,format:Fa.metaData,items:Fa.items,maxItems:Fa.maxItems,maxLength:Fa.maxLength6,maxProperties:Fa.maxProperties,maximum:Fa.maximum,minItems:Fa.minItems,minLength:Fa.minLength6,minProperties:Fa.minProperties,minimum:Fa.minimum,multipleOf:Fa.multipleOf,not:Fa.not,oneOf:Fa.oneOf,pattern:Fa.pattern,patternProperties:Fa.patternProperties,properties:Fa.properties,propertyNames:Fa.propertyNames,required:Fa.required,title:Fa.metaData,type:Fa.type,uniqueItems:Fa.uniqueItems});const{Core:Ya,Schema:ei}=jt,ti="http://json-schema.org/draft-07/schema";ei.setConfig(ti,"jrefToken","$ref"),ei.setConfig(ti,"idToken","$id"),ei.setConfig(ti,"anchorToken","$id"),ei.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),Ya.defineVocabulary(ti,{validate:Fa.validate,additionalItems:Fa.additionalItems6,additionalProperties:Fa.additionalProperties6,allOf:Fa.allOf,anyOf:Fa.anyOf,const:Fa.const,contains:Fa.contains,default:Fa.metaData,definitions:Fa.definitions,dependencies:Fa.dependencies,description:Fa.metaData,enum:Fa.enum,exclusiveMaximum:Fa.exclusiveMaximum,exclusiveMinimum:Fa.exclusiveMinimum,format:Fa.metaData,if:Fa.ifThenElse,items:Fa.items,maxItems:Fa.maxItems,maxLength:Fa.maxLength6,maxProperties:Fa.maxProperties,maximum:Fa.maximum,minItems:Fa.minItems,minLength:Fa.minLength6,minProperties:Fa.minProperties,minimum:Fa.minimum,multipleOf:Fa.multipleOf,not:Fa.not,oneOf:Fa.oneOf,pattern:Fa.pattern,patternProperties:Fa.patternProperties,properties:Fa.properties,propertyNames:Fa.propertyNames,readOnly:Fa.metaData,required:Fa.required,title:Fa.metaData,type:Fa.type,uniqueItems:Fa.uniqueItems,writeOnly:Fa.metaData});const{Core:ni,Schema:ri}=jt,ai="https://json-schema.org/draft/2019-09/schema";ri.setConfig(ai,"idToken","$id"),ri.setConfig(ai,"anchorToken","$anchor"),ri.setConfig(ai,"jsrefToken","$ref"),ri.setConfig(ai,"dynamicJsrefToken","$recursiveRef"),ri.setConfig(ai,"recursiveAnchorToken","$recursiveAnchor"),ri.setConfig(ai,"commentToken","$comment"),ri.setConfig(ai,"vocabulary",!0),ri.setConfig(ai,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),ri.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:Fa.validate,$defs:Fa.definitions,$recursiveRef:Fa.$recursiveRef,$ref:Fa.$ref}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:Fa.additionalItems6,additionalProperties:Fa.additionalProperties6,allOf:Fa.allOf,anyOf:Fa.anyOf,contains:Fa.containsMinContainsMaxContains,dependentSchemas:Fa.dependentSchemas,if:Fa.ifThenElse,items:Fa.items,not:Fa.not,oneOf:Fa.oneOf,patternProperties:Fa.patternProperties,properties:Fa.properties,propertyNames:Fa.propertyNames,unevaluatedItems:Fa.unevaluatedItems,unevaluatedProperties:Fa.unevaluatedProperties}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:Fa.const,dependentRequired:Fa.dependentRequired,enum:Fa.enum,exclusiveMaximum:Fa.exclusiveMaximum,exclusiveMinimum:Fa.exclusiveMinimum,maxItems:Fa.maxItems,maxLength:Fa.maxLength6,maxProperties:Fa.maxProperties,maximum:Fa.maximum,minItems:Fa.minItems,minLength:Fa.minLength6,minProperties:Fa.minProperties,minimum:Fa.minimum,multipleOf:Fa.multipleOf,pattern:Fa.pattern,required:Fa.required,type:Fa.type,uniqueItems:Fa.uniqueItems}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:Fa.metaData,deprecated:Fa.metaData,description:Fa.metaData,examples:Fa.metaData,readOnly:Fa.metaData,title:Fa.metaData,writeOnly:Fa.metaData}),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),ri.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),ni.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:Fa.metaData,contentMediaType:Fa.metaData,contentSchema:Fa.metaData});const{Core:ii,Schema:si}=jt;si.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/schema-object/2019-10",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true,\n        "https://spec.openapis.org/oas/3.1/vocab/validation/2019-10": true,\n        "https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/core"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/applicator"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/meta-data"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/format"},\n        {"$ref": "https://json-schema.org/draft/2019-09/meta/content"},\n        {"$ref": "https://spec.openapis.org/oas/3.1/meta/validation/2019-10"},\n        {"$ref": "https://spec.openapis.org/oas/3.1/meta/extensions/2019-10"}\n    ],\n    "type": ["object", "boolean"],\n    "unevaluatedProperties": false\n}')),si.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/validation/2019-10",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "$comment": "This is an alternate meta-schema for the standard validation vocabulary.  It is identical to the standard validation meta-schema except that it modifies minimum, maximum, exclusiveMinimum and exclusiveMaximum",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "required": ["exclusiveMinimum"],\n                "properties": {\n                    "exclusiveMinimum": {"type": "boolean"}\n                }\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "required": ["exclusiveMaximum"],\n                "properties": {\n                    "exclusiveMaximum": {"type": "boolean"}\n                }\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),ii.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/validation/2019-10",{const:Fa.const,dependentRequired:Fa.dependentRequired,enum:Fa.enum,exclusiveMaximum:Fa.exclusiveMaximumOas31,exclusiveMinimum:Fa.exclusiveMinimumOas31,maxItems:Fa.maxItems,maxLength:Fa.maxLength6,maxProperties:Fa.maxProperties,maximum:Fa.maximumExclusiveMaximumOas31,minItems:Fa.minItems,minLength:Fa.minLength6,minProperties:Fa.minProperties,minimum:Fa.minimumExclusiveMinimumOas31,multipleOf:Fa.multipleOf,pattern:Fa.pattern,required:Fa.required,type:Fa.type,uniqueItems:Fa.uniqueItems}),si.add(JSON.parse('{\n    "$id": "https://spec.openapis.org/oas/3.1/meta/extensions/2019-10",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10": true\n    },\n    "$recursiveAnchor": true,\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "example": true,\n        "nullable": {\n            "type": "boolean",\n            "default": false\n        },\n        "discriminator": {\n            "$ref": "#/$defs/Discriminator"\n        },\n        "externalDocs": {\n            "$ref": "#/$defs/ExternalDocs"\n        },\n        "xml": {\n            "$ref": "#/$defs/Xml"\n        }\n    },\n    "patternProperties": {\n        "^x-": true\n    },\n    "$defs": {\n        "Discriminator": {\n            "type": "object",\n            "required": ["propertyName"],\n            "properties": {\n                "propertyName": {\n                    "type": "string"\n                },\n                "mapping": {\n                    "additionalProperties": {\n                        "type": "string"\n                    }\n                }\n            },\n            "additionalProperties": false\n        },\n        "ExternalDocs": {\n            "type": "object",\n            "required": ["url"],\n            "properties": {\n                "url": {\n                    "type": "string",\n                    "format": "uri-reference"\n                },\n                "description": {\n                    "type": "string"\n                }\n            },\n            "patternProperties": {\n                "^x-": true\n            },\n            "additionalProperties": false\n        },\n        "Xml": {\n            "type": "object",\n            "properties": {\n                "name": {\n                    "type": "string"\n                },\n                "namespace": {\n                    "type": "string",\n                    "format": "uri"\n                },\n                "prefix": {\n                    "type": "string"\n                },\n                "attribute": {\n                    "type": "boolean"\n                },\n                "wrapped": {\n                    "type": "boolean"\n                }\n            },\n            "patternProperties": {\n                "^x-": true\n            },\n            "additionalProperties": false\n        }\n    }\n}')),ii.defineVocabulary("https://spec.openapis.org/oas/3.1/vocab/extensions/2019-10",{discriminator:Fa.metaData,example:Fa.metaData,externalDocs:Fa.metaData,nullable:Fa.metaData,xml:Fa.metaData});const{Core:oi,Schema:ci}=jt;var li={add:ci.add,get:ci.get,validate:oi.validate,setMetaOutputFormat:oi.setMetaOutputFormat,setShouldMetaValidate:oi.setShouldMetaValidate,FLAG:oi.FLAG,BASIC:oi.BASIC,DETAILED:oi.DETAILED,VERBOSE:oi.VERBOSE};const ui='(?:\\\\["\\/\\\\brfnt]|\\\\u[0-9a-fA-F]{4}|[^"\\\\])',mi=`"${ui}*"`,pi=`"${ui}*"(?=\\s*:)`;var fi=X(function(e){var t,n;t=L,n=function(){var e=Object.prototype.hasOwnProperty,t=Object.prototype.toString,n="boolean"==typeof(new RegExp).sticky;function r(e){return e&&"[object RegExp]"===t.call(e)}function a(e){return e&&"object"==typeof e&&!r(e)&&!Array.isArray(e)}function i(e){return"("+e+")"}function s(e){return e.length?"(?:"+e.map(function(e){return"(?:"+e+")"}).join("|")+")":"(?!)"}function o(e){if("string"==typeof e)return"(?:"+e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")+")";if(r(e)){if(e.ignoreCase)throw new Error("RegExp /i flag not allowed");if(e.global)throw new Error("RegExp /g flag is implied");if(e.sticky)throw new Error("RegExp /y flag is implied");if(e.multiline)throw new Error("RegExp /m flag is implied");return e.source}throw new Error("Not a pattern: "+e)}function c(t,n){if(a(n)||(n={match:n}),n.include)throw new Error("Matching rules cannot also include states");var i={defaultType:t,lineBreaks:!!n.error||!!n.fallback,pop:!1,next:null,push:null,error:!1,fallback:!1,value:null,type:null,shouldThrow:!1};for(var s in n)e.call(n,s)&&(i[s]=n[s]);if("string"==typeof i.type&&t!==i.type)throw new Error("Type transform cannot be a string (type '"+i.type+"' for token '"+t+"')");var o=i.match;return i.match=Array.isArray(o)?o:o?[o]:[],i.match.sort(function(e,t){return r(e)&&r(t)?0:r(t)?-1:r(e)?1:t.length-e.length}),i}function l(e){return Array.isArray(e)?function(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];if(r.include)for(var a=[].concat(r.include),i=0;i<a.length;i++)t.push({include:a[i]});else{if(!r.type)throw new Error("Rule has no type: "+JSON.stringify(r));t.push(c(r.type,r))}}return t}(e):function(e){for(var t=Object.getOwnPropertyNames(e),n=[],r=0;r<t.length;r++){var i=t[r],s=e[i],o=[].concat(s);if("include"!==i){var l=[];o.forEach(function(e){a(e)?(l.length&&n.push(c(i,l)),n.push(c(i,e)),l=[]):l.push(e)}),l.length&&n.push(c(i,l))}else for(var u=0;u<o.length;u++)n.push({include:o[u]})}return n}(e)}var u=c("error",{lineBreaks:!0,shouldThrow:!0});function m(e,t){for(var a=null,c=Object.create(null),l=!0,m=null,p=[],f=[],d=0;d<e.length;d++)e[d].fallback&&(l=!1);for(d=0;d<e.length;d++){var h=e[d];if(h.include)throw new Error("Inheritance is not allowed in stateless lexers");if(h.error||h.fallback){if(a)throw!h.fallback==!a.fallback?new Error("Multiple "+(h.fallback?"fallback":"error")+" rules not allowed (for token '"+h.defaultType+"')"):new Error("fallback and error are mutually exclusive (for token '"+h.defaultType+"')");a=h}var v=h.match.slice();if(l)for(;v.length&&"string"==typeof v[0]&&1===v[0].length;){c[v.shift().charCodeAt(0)]=h}if(h.pop||h.push||h.next){if(!t)throw new Error("State-switching options are not allowed in stateless lexers (for token '"+h.defaultType+"')");if(h.fallback)throw new Error("State-switching options are not allowed on fallback tokens (for token '"+h.defaultType+"')")}if(0!==v.length){l=!1,p.push(h);for(var y=0;y<v.length;y++){var g=v[y];if(r(g))if(null===m)m=g.unicode;else if(m!==g.unicode&&!1===h.fallback)throw new Error("If one rule is /u then all must be")}var $=s(v.map(o)),b=new RegExp($);if(b.test(""))throw new Error("RegExp matches empty string: "+b);if(new RegExp("|"+$).exec("").length-1>0)throw new Error("RegExp has capture groups: "+b+"\nUse (?: … ) instead");if(!h.lineBreaks&&b.test("\n"))throw new Error("Rule should declare lineBreaks: "+b);f.push(i($))}}var x=a&&a.fallback,w=n&&!x?"ym":"gm",I=n||x?"":"|";return!0===m&&(w+="u"),{regexp:new RegExp(s(f)+I,w),groups:p,fast:c,error:a||u}}function p(e,t,n){var r=e&&(e.push||e.next);if(r&&!n[r])throw new Error("Missing state '"+r+"' (in token '"+e.defaultType+"' of state '"+t+"')");if(e&&e.pop&&1!=+e.pop)throw new Error("pop must be 1 (in token '"+e.defaultType+"' of state '"+t+"')")}var f=function(e,t){this.startState=t,this.states=e,this.buffer="",this.stack=[],this.reset()};f.prototype.reset=function(e,t){return this.buffer=e||"",this.index=0,this.line=t?t.line:1,this.col=t?t.col:1,this.queuedToken=t?t.queuedToken:null,this.queuedThrow=t?t.queuedThrow:null,this.setState(t?t.state:this.startState),this.stack=t&&t.stack?t.stack.slice():[],this},f.prototype.save=function(){return{line:this.line,col:this.col,state:this.state,stack:this.stack.slice(),queuedToken:this.queuedToken,queuedThrow:this.queuedThrow}},f.prototype.setState=function(e){if(e&&this.state!==e){this.state=e;var t=this.states[e];this.groups=t.groups,this.error=t.error,this.re=t.regexp,this.fast=t.fast}},f.prototype.popState=function(){this.setState(this.stack.pop())},f.prototype.pushState=function(e){this.stack.push(this.state),this.setState(e)};var d=n?function(e,t){return e.exec(t)}:function(e,t){var n=e.exec(t);return 0===n[0].length?null:n};function h(){return this.value}if(f.prototype._getGroup=function(e){for(var t=this.groups.length,n=0;n<t;n++)if(void 0!==e[n+1])return this.groups[n];throw new Error("Cannot find token type for matched text")},f.prototype.next=function(){var e=this.index;if(this.queuedGroup){var t=this._token(this.queuedGroup,this.queuedText,e);return this.queuedGroup=null,this.queuedText="",t}var n=this.buffer;if(e!==n.length){if(s=this.fast[n.charCodeAt(e)])return this._token(s,n.charAt(e),e);var r=this.re;r.lastIndex=e;var a=d(r,n),i=this.error;if(null==a)return this._token(i,n.slice(e,n.length),e);var s=this._getGroup(a),o=a[0];return i.fallback&&a.index!==e?(this.queuedGroup=s,this.queuedText=o,this._token(i,n.slice(e,a.index),e)):this._token(s,o,e)}},f.prototype._token=function(e,t,n){var r=0;if(e.lineBreaks){var a=/\n/g,i=1;if("\n"===t)r=1;else for(;a.exec(t);)r++,i=a.lastIndex}var s={type:"function"==typeof e.type&&e.type(t)||e.defaultType,value:"function"==typeof e.value?e.value(t):t,text:t,toString:h,offset:n,lineBreaks:r,line:this.line,col:this.col},o=t.length;if(this.index+=o,this.line+=r,0!==r?this.col=o-i+1:this.col+=o,e.shouldThrow)throw new Error(this.formatError(s,"invalid syntax"));return e.pop?this.popState():e.push?this.pushState(e.push):e.next&&this.setState(e.next),s},"undefined"!=typeof Symbol&&Symbol.iterator){var v=function(e){this.lexer=e};v.prototype.next=function(){var e=this.lexer.next();return{value:e,done:!e}},v.prototype[Symbol.iterator]=function(){return this},f.prototype[Symbol.iterator]=function(){return new v(this)}}return f.prototype.formatError=function(e,t){if(null==e){var n=this.buffer.slice(this.index);e={text:n,offset:this.index,lineBreaks:-1===n.indexOf("\n")?0:1,line:this.line,col:this.col}}var r=Math.max(0,e.offset-e.col+1),a=e.lineBreaks?e.text.indexOf("\n"):e.text.length,i=this.buffer.substring(r,e.offset+a);return t+=" at line "+e.line+" col "+e.col+":\n\n",t+="  "+i+"\n",t+="  "+Array(e.col).join(" ")+"^"},f.prototype.clone=function(){return new f(this.states,this.state)},f.prototype.has=function(e){return!0},{compile:function(e){var t=m(l(e));return new f({start:t},"start")},states:function(e,t){var n=e.$all?l(e.$all):[];delete e.$all;var r=Object.getOwnPropertyNames(e);t||(t=r[0]);for(var a=Object.create(null),i=0;i<r.length;i++)a[$=r[i]]=l(e[$]).concat(n);for(i=0;i<r.length;i++)for(var s=a[$=r[i]],o=Object.create(null),c=0;c<s.length;c++){var u=s[c];if(u.include){var d=[c,1];if(u.include!==$&&!o[u.include]){o[u.include]=!0;var h=a[u.include];if(!h)throw new Error("Cannot include nonexistent state '"+u.include+"' (in state '"+$+"')");for(var v=0;v<h.length;v++){var y=h[v];-1===s.indexOf(y)&&d.push(y)}}s.splice.apply(s,d),c--}}var g=Object.create(null);for(i=0;i<r.length;i++){var $;g[$=r[i]]=m(a[$],!0)}for(i=0;i<r.length;i++){var b=r[i],x=g[b],w=x.groups;for(c=0;c<w.length;c++)p(w[c],b,g);var I=Object.getOwnPropertyNames(x.fast);for(c=0;c<I.length;c++)p(x.fast[I[c]],b,g)}return new f(g,t)},error:Object.freeze({error:!0}),fallback:Object.freeze({fallback:!0}),keywords:function(e){for(var t=Object.create(null),n=Object.create(null),r=Object.getOwnPropertyNames(e),a=0;a<r.length;a++){var i=r[a],s=e[i];(Array.isArray(s)?s:[s]).forEach(function(e){if((n[e.length]=n[e.length]||[]).push(e),"string"!=typeof e)throw new Error("keyword must be string (in keyword '"+i+"')");t[e]=i})}function o(e){return JSON.stringify(e)}var c="";for(var l in c+="switch (value.length) {\n",n){var u=n[l];c+="case "+l+":\n",c+="switch (value) {\n",u.forEach(function(e){var n=t[e];c+="case "+o(e)+": return "+o(n)+"\n"}),c+="}\n"}return c+="}\n",Function("value",c)}}},e.exports?e.exports=n():t.moo=n()}).compile({WS:{match:/(?:(?:\r?\n)|[ \t])+/,lineBreaks:!0},punctuation:/[:,]/,number:new RegExp("-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+][0-9]+)?"),property:new RegExp(pi),string:new RegExp(mi),grouping:["{","}","[","]"],boolean:["true","false"],null:["null"],other:/./});function di(e,t,n){const r=e.slice();return r[6]=t[n],r}function hi(e,t,n){const r=e.slice();return r[9]=t[n],r[11]=n,r}function vi(e){let t,n,f=e[11]+1+"";return{c(){t=r("div"),n=a(f),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);n=o(r,f),r.forEach(c),this.h()},h(){l(t,"class","svelte-l280wh")},m(e,r){u(e,t,r),m(t,n)},p:p,d(e){e&&c(t)}}}function yi(e){let t,n=e[6].value+"";return{c(){t=a(n)},l(e){t=o(e,n)},m(e,n){u(e,t,n)},p(e,r){8&r&&n!==(n=e[6].value+"")&&x(t,n)},d(e){e&&c(t)}}}function gi(e){let t,n,p=e[6].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","null svelte-l280wh")},m(e,r){u(e,t,r),m(t,n)},p(e,t){8&t&&p!==(p=e[6].value+"")&&x(n,p)},d(e){e&&c(t)}}}function $i(e){let t,n,p=e[6].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","boolean svelte-l280wh")},m(e,r){u(e,t,r),m(t,n)},p(e,t){8&t&&p!==(p=e[6].value+"")&&x(n,p)},d(e){e&&c(t)}}}function bi(e){let t,n,p=e[6].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","number svelte-l280wh")},m(e,r){u(e,t,r),m(t,n)},p(e,t){8&t&&p!==(p=e[6].value+"")&&x(n,p)},d(e){e&&c(t)}}}function xi(e){let t,n,p,f,d=e[6].value.substring(1,e[6].value.length-1)+"";return{c(){t=a('"'),n=r("span"),p=a(d),f=a('"'),this.h()},l(e){t=o(e,'"'),n=i(e,"SPAN",{class:!0});var r=s(n);p=o(r,d),r.forEach(c),f=o(e,'"'),this.h()},h(){l(n,"class","string svelte-l280wh")},m(e,r){u(e,t,r),u(e,n,r),m(n,p),u(e,f,r)},p(e,t){8&t&&d!==(d=e[6].value.substring(1,e[6].value.length-1)+"")&&x(p,d)},d(e){e&&c(t),e&&c(n),e&&c(f)}}}function wi(e){let t,n,p,f,d=e[6].value.substring(1,e[6].value.length-1)+"";return{c(){t=a('"'),n=r("span"),p=a(d),f=a('"'),this.h()},l(e){t=o(e,'"'),n=i(e,"SPAN",{class:!0});var r=s(n);p=o(r,d),r.forEach(c),f=o(e,'"'),this.h()},h(){l(n,"class","property svelte-l280wh")},m(e,r){u(e,t,r),u(e,n,r),m(n,p),u(e,f,r)},p(e,t){8&t&&d!==(d=e[6].value.substring(1,e[6].value.length-1)+"")&&x(p,d)},d(e){e&&c(t),e&&c(n),e&&c(f)}}}function Ii(e){let t,n,p=e[6].value+"";return{c(){t=r("span"),n=a(p),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,p),r.forEach(c),this.h()},h(){l(t,"class","grouping svelte-l280wh")},m(e,r){u(e,t,r),m(t,n)},p(e,t){8&t&&p!==(p=e[6].value+"")&&x(n,p)},d(e){e&&c(t)}}}function ji(e){let t;function n(e,t){return"grouping"===e[6].type?Ii:"property"===e[6].type?wi:"string"===e[6].type?xi:"number"===e[6].type?bi:"boolean"===e[6].type?$i:"null"===e[6].type?gi:yi}let r=n(e),a=r(e);return{c(){a.c(),t=f()},l(e){a.l(e),t=f()},m(e,n){a.m(e,n),u(e,t,n)},p(e,i){r===(r=n(e))&&a?a.p(e,i):(a.d(1),(a=r(e))&&(a.c(),a.m(t.parentNode,t)))},d(e){a.d(e),e&&c(t)}}}function Oi(e){let t,n,a,o,f,b,x,w,I,j,O=[...Array(e[2])],E=[];for(let t=0;t<O.length;t+=1)E[t]=vi(hi(e,O,t));let S=e[3],A=[];for(let t=0;t<S.length;t+=1)A[t]=ji(di(e,S,t));return{c(){t=r("div"),n=r("div");for(let e=0;e<E.length;e+=1)E[e].c();a=d(),o=r("div"),f=r("pre");for(let e=0;e<A.length;e+=1)A[e].c();b=d(),x=r("textarea"),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);n=i(r,"DIV",{class:!0});var l=s(n);for(let e=0;e<E.length;e+=1)E[e].l(l);l.forEach(c),a=h(r),o=i(r,"DIV",{class:!0});var u=s(o);f=i(u,"PRE",{class:!0});var m=s(f);for(let e=0;e<A.length;e+=1)A[e].l(m);m.forEach(c),b=h(u),x=i(u,"TEXTAREA",{class:!0,"aria-label":!0}),s(x).forEach(c),u.forEach(c),r.forEach(c),this.h()},h(){l(n,"class","line-numbers svelte-l280wh"),l(f,"class","highlighted svelte-l280wh"),l(x,"class","src svelte-l280wh"),l(x,"aria-label","Code Editor"),l(o,"class","editable svelte-l280wh"),l(t,"class",w="Editor "+e[1]+" svelte-l280wh")},m(r,i){u(r,t,i),m(t,n);for(let e=0;e<E.length;e+=1)E[e].m(n,null);m(t,a),m(t,o),m(o,f);for(let e=0;e<A.length;e+=1)A[e].m(f,null);m(o,b),m(o,x),v(x,e[0]),I||(j=[y(x,"input",e[5]),y(x,"input",e[4])],I=!0)},p(e,[r]){if(4&r){let t;for(O=[...Array(e[2])],t=0;t<O.length;t+=1){const a=hi(e,O,t);E[t]?E[t].p(a,r):(E[t]=vi(a),E[t].c(),E[t].m(n,null))}for(;t<E.length;t+=1)E[t].d(1);E.length=O.length}if(8&r){let t;for(S=e[3],t=0;t<S.length;t+=1){const n=di(e,S,t);A[t]?A[t].p(n,r):(A[t]=ji(n),A[t].c(),A[t].m(f,null))}for(;t<A.length;t+=1)A[t].d(1);A.length=S.length}1&r&&v(x,e[0]),2&r&&w!==(w="Editor "+e[1]+" svelte-l280wh")&&l(t,"class",w)},i:p,o:p,d(e){e&&c(t),g(E,e),g(A,e),I=!1,$(j)}}}function Ei(e,t,n){let r,a,{theme:i="solarized-dark"}=t,{value:s=""}=t;return e.$set=(e=>{"theme"in e&&n(1,i=e.theme),"value"in e&&n(0,s=e.value)}),e.$$.update=(()=>{1&e.$$.dirty&&n(2,r=(s.match(/\n/g)||[]).length+1),1&e.$$.dirty&&n(3,(fi.reset(s),a=Array.from(fi)))}),[s,i,r,a,function(t){b(e,t)},function(){s=this.value,n(0,s)}]}class Si extends e{constructor(e){super(),t(this,e,Ei,Oi,n,{theme:1,value:0})}}function Ai(e,t,n){const r=e.slice();return r[13]=t[n],r[15]=n,r}function Pi(e){let t,n,p,f;function d(...t){return e[10](e[15],...t)}return{c(){t=r("span"),n=a("×"),this.h()},l(e){t=i(e,"SPAN",{class:!0});var r=s(t);n=o(r,"×"),r.forEach(c),this.h()},h(){l(t,"class","close svelte-4eu6m3")},m(e,r){u(e,t,r),m(t,n),p||(f=y(t,"click",d),p=!0)},p(t,n){e=t},d(e){e&&c(t),p=!1,f()}}}function ki(e){let t,n,p,f,v,g,$=e[13].label+"";function b(...t){return e[9](e[15],...t)}let I=!e[13].persistent&&e[0].length>e[4]&&Pi(e);return{c(){t=r("div"),n=r("span"),p=a($),f=d(),I&&I.c(),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);n=i(r,"SPAN",{class:!0});var a=s(n);p=o(a,$),a.forEach(c),f=h(r),I&&I.l(r),r.forEach(c),this.h()},h(){l(n,"class","label svelte-4eu6m3"),l(t,"class","tab svelte-4eu6m3"),w(t,"selected",e[15]===e[1]),w(t,"active",e[15]===e[3])},m(e,r){u(e,t,r),m(t,n),m(n,p),m(t,f),I&&I.m(t,null),v||(g=y(n,"click",b),v=!0)},p(n,r){e=n,1&r&&$!==($=e[13].label+"")&&x(p,$),!e[13].persistent&&e[0].length>e[4]?I?I.p(e,r):((I=Pi(e)).c(),I.m(t,null)):I&&(I.d(1),I=null),2&r&&w(t,"selected",e[15]===e[1]),8&r&&w(t,"active",e[15]===e[3])},d(e){e&&c(t),I&&I.d(),v=!1,g()}}}function Ni(e){let t,n,f,d,h;return{c(){t=r("div"),n=r("span"),f=a("+"),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);n=i(r,"SPAN",{class:!0});var a=s(n);f=o(a,"+"),a.forEach(c),r.forEach(c),this.h()},h(){l(n,"class","label svelte-4eu6m3"),l(t,"class","tab svelte-4eu6m3")},m(r,a){u(r,t,a),m(t,n),m(n,f),d||(h=y(t,"click",e[7]),d=!0)},p:p,d(e){e&&c(t),d=!1,h()}}}function Ti(e){let t,n,a,o,p,f=e[0],v=[];for(let t=0;t<f.length;t+=1)v[t]=ki(Ai(e,f,t));let y=e[2]&&Ni(e);function $(t){e[11].call(null,t)}let b={};void 0!==e[0][e[1]].text&&(b.value=e[0][e[1]].text);const x=new Si({props:b});return I.push(()=>j(x,"value",$)),x.$on("input",e[12]),{c(){t=r("div");for(let e=0;e<v.length;e+=1)v[e].c();n=d(),y&&y.c(),a=d(),O(x.$$.fragment),this.h()},l(e){t=i(e,"DIV",{class:!0});var r=s(t);for(let e=0;e<v.length;e+=1)v[e].l(r);n=h(r),y&&y.l(r),r.forEach(c),a=h(e),E(x.$$.fragment,e),this.h()},h(){l(t,"class","tabs svelte-4eu6m3")},m(e,r){u(e,t,r);for(let e=0;e<v.length;e+=1)v[e].m(t,null);m(t,n),y&&y.m(t,null),u(e,a,r),S(x,e,r),p=!0},p(e,[r]){if(347&r){let a;for(f=e[0],a=0;a<f.length;a+=1){const i=Ai(e,f,a);v[a]?v[a].p(i,r):(v[a]=ki(i),v[a].c(),v[a].m(t,n))}for(;a<v.length;a+=1)v[a].d(1);v.length=f.length}e[2]?y?y.p(e,r):((y=Ni(e)).c(),y.m(t,null)):y&&(y.d(1),y=null);const a={};!o&&3&r&&(o=!0,a.value=e[0][e[1]].text,A(()=>o=!1)),x.$set(a)},i(e){p||(P(x.$$.fragment,e),p=!0)},o(e){k(x.$$.fragment,e),p=!1},d(e){e&&c(t),g(v,e),y&&y.d(),e&&c(a),N(x,e)}}}function qi(e,t,n){let{tabs:r=[]}=t,{newTab:a}=t,{active:i=0}=t,{selected:s=0}=t,{minTabs:o=1}=t;const c=T();function l(e){n(1,s=e)}function u(e){s>=e&&s>0&&n(1,s-=1),r.splice(e,1),n(0,r)}return e.$set=(e=>{"tabs"in e&&n(0,r=e.tabs),"newTab"in e&&n(2,a=e.newTab),"active"in e&&n(3,i=e.active),"selected"in e&&n(1,s=e.selected),"minTabs"in e&&n(4,o=e.minTabs)}),[r,s,a,i,o,c,l,function(){n(0,r[r.length]=a(),r),n(1,s=r.length-1)},u,e=>l(e),e=>u(e),function(e){r[s].text=e,n(0,r)},e=>c("input",r)]}class Ri extends e{constructor(e){super(),t(this,e,qi,Ti,n,{tabs:0,newTab:2,active:3,selected:1,minTabs:4})}}function Ci(e,t,n){const r=e.slice();return r[2]=t[n],r}function Mi(e){let t;function n(e,t){return e[1].absoluteKeywordLocation?Vi:Di}let r=n(e),a=r(e);return{c(){a.c(),t=f()},l(e){a.l(e),t=f()},m(e,n){a.m(e,n),u(e,t,n)},p(e,i){r===(r=n(e))&&a?a.p(e,i):(a.d(1),(a=r(e))&&(a.c(),a.m(t.parentNode,t)))},d(e){a.d(e),e&&c(t)}}}function Di(e){let t,n=e[1]+"";return{c(){t=a(n)},l(e){t=o(e,n)},m(e,n){u(e,t,n)},p(e,r){1&r&&n!==(n=e[1]+"")&&x(t,n)},d(e){e&&c(t)}}}function Vi(e){let t,n,l=e[1].errors,m=[];for(let t=0;t<l.length;t+=1)m[t]=Xi(Ci(e,l,t));return{c(){t=a("Invalid\n    "),n=r("ul");for(let e=0;e<m.length;e+=1)m[e].c()},l(e){t=o(e,"Invalid\n    "),n=i(e,"UL",{});var r=s(n);for(let e=0;e<m.length;e+=1)m[e].l(r);r.forEach(c)},m(e,r){u(e,t,r),u(e,n,r);for(let e=0;e<m.length;e+=1)m[e].m(n,null)},p(e,t){if(1&t){let r;for(l=e[1].errors,r=0;r<l.length;r+=1){const a=Ci(e,l,r);m[r]?m[r].p(a,t):(m[r]=Xi(a),m[r].c(),m[r].m(n,null))}for(;r<m.length;r+=1)m[r].d(1);m.length=l.length}},d(e){e&&c(t),e&&c(n),g(m,e)}}}function Li(e){let t,n,p,f,d,h,v=e[2].instanceLocation+"",y=e[2].absoluteKeywordLocation+"";return{c(){t=r("li"),n=r("code"),p=a(v),f=a(" fails schema constraint "),d=r("code"),h=a(y),this.h()},l(e){t=i(e,"LI",{class:!0});var r=s(t);n=i(r,"CODE",{class:!0});var a=s(n);p=o(a,v),a.forEach(c),f=o(r," fails schema constraint "),d=i(r,"CODE",{class:!0});var l=s(d);h=o(l,y),l.forEach(c),r.forEach(c),this.h()},h(){l(n,"class","svelte-1sdf2dp"),l(d,"class","svelte-1sdf2dp"),l(t,"class","svelte-1sdf2dp")},m(e,r){u(e,t,r),m(t,n),m(n,p),m(t,f),m(t,d),m(d,h)},p(e,t){1&t&&v!==(v=e[2].instanceLocation+"")&&x(p,v),1&t&&y!==(y=e[2].absoluteKeywordLocation+"")&&x(h,y)},d(e){e&&c(t)}}}function Xi(e){let t,n=!e[2].valid&&Li(e);return{c(){n&&n.c(),t=f()},l(e){n&&n.l(e),t=f()},m(e,r){n&&n.m(e,r),u(e,t,r)},p(e,r){e[2].valid?n&&(n.d(1),n=null):n?n.p(e,r):((n=Li(e)).c(),n.m(t.parentNode,t))},d(e){n&&n.d(e),e&&c(t)}}}function Ji(e){let t,n=e[0]?"Valid":"";return{c(){t=a(n)},l(e){t=o(e,n)},m(e,n){u(e,t,n)},p(e,r){1&r&&n!==(n=e[0]?"Valid":"")&&x(t,n)},d(e){e&&c(t)}}}function _i(e){let t;return{c(){t=a("Validating ...")},l(e){t=o(e,"Validating ...")},m(e,n){u(e,t,n)},p:p,d(e){e&&c(t)}}}function zi(e){let t,n,r={ctx:e,current:null,token:null,pending:_i,then:Ji,catch:Mi,value:0,error:1};return q(n=e[0],r),{c(){t=f(),r.block.c()},l(e){t=f(),r.block.l(e)},m(e,n){u(e,t,n),r.block.m(e,r.anchor=n),r.mount=(()=>t.parentNode),r.anchor=t},p(t,[a]){if(e=t,r.ctx=e,1&a&&n!==(n=e[0])&&q(n,r));else{const t=e.slice();t[0]=r.resolved,r.block.p(t,a)}},i:p,o:p,d(e){e&&c(t),r.block.d(e),r.token=null,r=null}}}function Bi(e,t,n){let{results:r}=t;return e.$set=(e=>{"results"in e&&n(0,r=e.results)}),[r]}class Fi extends e{constructor(e){super(),t(this,e,Bi,zi,n,{results:0})}}function Ki(e){let t,n,a,o,p;const f=e[2].default,v=R(f,e,e[1],null);return{c(){t=r("a"),n=C("svg"),a=C("path"),o=d(),v&&v.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var r=s(t);n=i(r,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(n);a=i(l,"path",{"fill-rule":!0,d:!0},1),s(a).forEach(c),l.forEach(c),o=h(r),v&&v.l(r),r.forEach(c),this.h()},h(){l(a,"fill-rule","evenodd"),l(a,"d","M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"),l(n,"height","1.5em"),l(n,"viewBox","0 0 16 16"),l(n,"version","1.1"),l(n,"aria-hidden","true"),l(n,"class","svelte-i8toq"),l(t,"href",e[0]),l(t,"class","svelte-i8toq")},m(e,r){u(e,t,r),m(t,n),m(n,a),m(t,o),v&&v.m(t,null),p=!0},p(e,[n]){v&&v.p&&2&n&&M(v,f,e,e[1],n,null,null),(!p||1&n)&&l(t,"href",e[0])},i(e){p||(P(v,e),p=!0)},o(e){k(v,e),p=!1},d(e){e&&c(t),v&&v.d(e)}}}function Ui(e,t,n){let{href:r=""}=t,{$$slots:a={},$$scope:i}=t;return e.$set=(e=>{"href"in e&&n(0,r=e.href),"$$scope"in e&&n(1,i=e.$$scope)}),[r,i,a]}class Gi extends e{constructor(e){super(),t(this,e,Ui,Ki,n,{href:0})}}function Wi(e){let t,n,a,o,p;const f=e[2].default,v=R(f,e,e[1],null);return{c(){t=r("a"),n=C("svg"),a=C("path"),o=d(),v&&v.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var r=s(t);n=i(r,"svg",{height:!0,viewBox:!0,version:!0,"aria-hidden":!0,class:!0},1);var l=s(n);a=i(l,"path",{d:!0},1),s(a).forEach(c),l.forEach(c),o=h(r),v&&v.l(r),r.forEach(c),this.h()},h(){l(a,"d","M240,250h100v-50h100V0H240V250z M340,50h50v100h-50V50z M480,0v200h100V50h50v150h50V50h50v150h50V0H480z M0,200h100V50h50v150h50V0H0V200z"),l(n,"height","1em"),l(n,"viewBox","0 0 780 250"),l(n,"version","1.1"),l(n,"aria-hidden","true"),l(n,"class","svelte-wj8h0n"),l(t,"href",e[0]),l(t,"class","svelte-wj8h0n")},m(e,r){u(e,t,r),m(t,n),m(n,a),m(t,o),v&&v.m(t,null),p=!0},p(e,[n]){v&&v.p&&2&n&&M(v,f,e,e[1],n,null,null),(!p||1&n)&&l(t,"href",e[0])},i(e){p||(P(v,e),p=!0)},o(e){k(v,e),p=!1},d(e){e&&c(t),v&&v.d(e)}}}function Hi(e,t,n){let{href:r=""}=t,{$$slots:a={},$$scope:i}=t;return e.$set=(e=>{"href"in e&&n(0,r=e.href),"$$scope"in e&&n(1,i=e.$$scope)}),[r,i,a]}class Zi extends e{constructor(e){super(),t(this,e,Hi,Wi,n,{href:0})}}function Qi(e){let t,n,a,o,p,f,v,y,g;const $=e[2].default,b=R($,e,e[1],null);return{c(){t=r("a"),n=C("svg"),a=C("g"),o=C("path"),p=C("path"),f=C("path"),v=C("path"),y=d(),b&&b.c(),this.h()},l(e){t=i(e,"A",{href:!0,class:!0});var r=s(t);n=i(r,"svg",{version:!0,viewBox:!0,height:!0,class:!0},1);var l=s(n);a=i(l,"g",{transform:!0,id:!0},1);var u=s(a);o=i(u,"path",{id:!0,d:!0,style:!0},1),s(o).forEach(c),p=i(u,"path",{id:!0,d:!0,style:!0},1),s(p).forEach(c),f=i(u,"path",{id:!0,d:!0,style:!0},1),s(f).forEach(c),v=i(u,"path",{id:!0,d:!0,style:!0},1),s(v).forEach(c),u.forEach(c),l.forEach(c),y=h(r),b&&b.l(r),r.forEach(c),this.h()},h(){l(o,"id","path4544"),l(o,"d","m 122.99401,114.18985 c -4.32897,-0.9404 -7.58044,-3.47848 -8.71251,-6.80095 -0.78921,-2.31618 -0.67682,-6.07238 0.33363,-11.150598 0.48507,-2.437836 0.88169,-5.347843 0.88139,-6.466688 -9.8e-4,-3.718098 -1.71106,-5.735418 -5.1001,-6.016462 l -1.9549,-0.162116 v -2.392655 -2.392657 l 1.85208,-0.250855 c 2.70243,-0.366031 3.74441,-1.02838 4.57629,-2.908984 0.61121,-1.381726 0.68884,-2.068648 0.50552,-4.472869 -0.11913,-1.562244 -0.53527,-4.348568 -0.92477,-6.191832 -0.98954,-4.682868 -0.94822,-8.485471 0.11707,-10.773163 1.56862,-3.368589 5.43705,-5.854553 9.93248,-6.382903 l 1.93299,-0.227185 v 2.518015 2.518015 h -1.29973 c -1.77186,0 -4.2497,1.262413 -4.8835,2.488054 -0.60797,1.175674 -0.65405,2.864146 -0.15834,5.802223 0.78343,4.643508 1.04707,9.098344 0.67592,11.421636 -0.42464,2.658142 -1.97477,5.796328 -3.6791,7.448236 l -1.18012,1.143813 1.61497,1.982752 c 1.99051,2.443801 2.76458,4.148744 3.24284,7.142561 0.37835,2.368341 0.0844,7.282673 -0.67072,11.213982 -1.05359,5.48514 0.1623,7.65141 4.66209,8.30613 l 1.67569,0.24382 v 2.44782 c 0,2.79211 0.17086,2.69708 -3.43917,1.91286 z"),D(o,"fill","stroke-width:0.35277775"),l(p,"id","path4546"),l(p,"d","m 152.2304,112.24932 v -2.42987 l 2.04969,-0.42336 c 2.26276,-0.46736 4.054,-1.8634 4.45842,-3.47475 0.1274,-0.50758 -0.11267,-3.16398 -0.53347,-5.90311 -1.37183,-8.929552 -0.6114,-13.537042 2.85482,-17.297452 l 1.48237,-1.60818 -1.1108,-1.26512 c -3.97855,-4.53132 -4.66885,-8.552208 -3.15364,-18.369547 0.76342,-4.946305 0.76409,-4.994322 0.087,-6.173611 -0.79713,-1.388278 -3.28385,-2.776033 -4.97438,-2.776033 h -1.15997 v -2.469445 c 0,-2.811057 -0.0583,-2.773846 3.24583,-2.072788 3.9645,0.841179 6.80448,2.853272 8.27787,5.864775 0.84544,1.728026 0.97275,2.400136 0.94911,5.010889 -0.015,1.658349 -0.35758,4.682054 -0.76125,6.719346 -1.49867,7.563594 -1.3651,9.576204 0.7654,11.532814 0.98915,0.90842 1.64012,1.17274 3.37032,1.36849 l 2.14439,0.24261 v 2.42387 2.42388 l -1.6757,7.1e-4 c -2.1517,7e-4 -3.9323,0.90924 -4.83869,2.46889 -0.95194,1.63803 -0.89239,5.20675 0.17364,10.40695 0.90648,4.421902 1.05253,8.458452 0.3882,10.728752 -0.70059,2.39406 -3.81995,5.29609 -6.74745,6.27718 -1.26118,0.42266 -2.96775,0.87096 -3.79236,0.99623 l -1.49931,0.22775 z"),D(p,"stroke-width","0.35277778"),l(f,"id","path4548"),l(f,"d","m 131.74239,108.26592 c -1.02163,-1.2988 -0.87294,-3.53652 0.38087,-5.73185 0.92776,-1.62446 4.80862,-6.948549 7.61066,-10.440949 l 1.13094,-1.40958 -1.80213,-5.22523 c -2.02147,-5.86123 -2.0098,-5.97467 0.65581,-6.37225 l 1.46834,-0.219 1.64076,3.3506 c 0.90242,1.84283 1.76982,3.35061 1.92755,3.35061 0.15774,0 1.77489,-1.75542 3.59368,-3.90092 3.15918,-3.72667 3.35688,-3.89165 4.42591,-3.69334 0.64552,0.11974 1.21858,0.0465 1.35432,-0.17316 0.31818,-0.51481 1.23083,0.24704 1.23083,1.02746 0,0.32009 -0.45438,1.13409 -1.00972,1.80888 -2.26771,2.75549 -7.10417,9.27155 -7.10417,9.5713 0,0.17685 0.97502,2.45302 2.16671,5.05816 l 2.1667,4.736609 -0.65823,0.98459 c -0.36203,0.54152 -0.66236,1.12603 -0.6674,1.29891 -0.005,0.17288 -0.27769,0.48371 -0.60588,0.69073 -0.83174,0.52464 -1.44656,-0.11541 -3.9894,-4.153119 -1.16417,-1.84856 -2.23163,-3.36491 -2.37215,-3.36967 -0.31309,-0.0106 -3.7911,5.131969 -6.47955,9.580639 -2.37093,3.92324 -1.93885,3.4204 -3.26614,3.80106 -0.95533,0.27398 -1.19348,0.19843 -1.79831,-0.57048 z"),D(f,"stroke-width","0.35277775"),l(v,"id","path4550"),l(v,"d","m 131.98567,83.677091 c -2.15148,-3.8472 -6.0183,-9.42829 -7.57842,-10.93815 -0.79252,-0.76698 -1.44094,-1.57494 -1.44094,-1.79546 0,-0.6016 1.61695,-1.21975 3.19058,-1.21975 1.69822,0 3.49597,1.47777 5.0997,4.19203 0.58208,0.98515 1.15641,1.79434 1.27629,1.79819 0.11988,0.004 0.80873,-1.65116 1.53078,-3.67779 1.5464,-4.34039 5.62351,-12.777999 7.22453,-14.951229 1.3726,-1.86316 3.42936,-2.865165 5.90274,-2.875676 3.23375,-0.01374 3.24268,0.130067 0.20474,3.296663 -4.63599,4.832327 -6.76321,8.809632 -11.25155,21.037252 -1.24637,3.39549 -2.39032,6.47895 -2.54212,6.85214 -0.23022,0.56597 -0.49833,0.28096 -1.61633,-1.71822 z"),D(v,"stroke-width","0.35277775"),l(a,"transform","translate(-104.22785,-45.507923)"),l(a,"id","layer1"),l(n,"version","1.1"),l(n,"viewBox","0 0 70.423268 70.42326"),l(n,"height","1.25em"),l(n,"class","svelte-27u907"),l(t,"href",e[0]),l(t,"class","svelte-27u907")},m(e,r){u(e,t,r),m(t,n),m(n,a),m(a,o),m(a,p),m(a,f),m(a,v),m(t,y),b&&b.m(t,null),g=!0},p(e,[n]){b&&b.p&&2&n&&M(b,$,e,e[1],n,null,null),(!g||1&n)&&l(t,"href",e[0])},i(e){g||(P(b,e),g=!0)},o(e){k(b,e),g=!1},d(e){e&&c(t),b&&b.d(e)}}}function Yi(e,t,n){let{href:r=""}=t,{$$slots:a={},$$scope:i}=t;return e.$set=(e=>{"href"in e&&n(0,r=e.href),"$$scope"in e&&n(1,i=e.$$scope)}),[r,i,a]}class es extends e{constructor(e){super(),t(this,e,Yi,Qi,n,{href:0})}}function ts(e){let t;return{c(){t=a("hyperjump-io/json-schema.hyperjump.io")},l(e){t=o(e,"hyperjump-io/json-schema.hyperjump.io")},m(e,n){u(e,t,n)},d(e){e&&c(t)}}}function ns(e){let t;return{c(){t=a("hyperjump-io/json-schema-validator")},l(e){t=o(e,"hyperjump-io/json-schema-validator")},m(e,n){u(e,t,n)},d(e){e&&c(t)}}}function rs(e){let t;return{c(){t=a("@hyperjump/json-schema")},l(e){t=o(e,"@hyperjump/json-schema")},m(e,n){u(e,t,n)},d(e){e&&c(t)}}}function as(e){let t;return{c(){t=a("@hyperjump/json-schema-core")},l(e){t=o(e,"@hyperjump/json-schema-core")},m(e,n){u(e,t,n)},d(e){e&&c(t)}}}function is(e){let t;return{c(){t=a("JSON Schema")},l(e){t=o(e,"JSON Schema")},m(e,n){u(e,t,n)},d(e){e&&c(t)}}}function ss(e){let t,n,a,o,p,f,v,y,g,$,b,x;const w=new Gi({props:{href:"https://github.com/hyperjump-io/json-schema.hyperjump.io",$$slots:{default:[ts]},$$scope:{ctx:e}}}),I=new Gi({props:{href:"https://github.com/hyperjump-io/json-schema-validator",$$slots:{default:[ns]},$$scope:{ctx:e}}}),j=new Zi({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema",$$slots:{default:[rs]},$$scope:{ctx:e}}}),A=new Zi({props:{href:"https://www.npmjs.com/package/@hyperjump/json-schema-core",$$slots:{default:[as]},$$scope:{ctx:e}}}),T=new es({props:{href:"https://json-schema.org",$$slots:{default:[is]},$$scope:{ctx:e}}});return{c(){t=r("footer"),n=r("ul"),a=r("li"),O(w.$$.fragment),o=d(),p=r("li"),O(I.$$.fragment),f=d(),v=r("li"),O(j.$$.fragment),y=d(),g=r("li"),O(A.$$.fragment),$=d(),b=r("li"),O(T.$$.fragment),this.h()},l(e){t=i(e,"FOOTER",{class:!0});var r=s(t);n=i(r,"UL",{class:!0});var l=s(n);a=i(l,"LI",{class:!0});var u=s(a);E(w.$$.fragment,u),u.forEach(c),o=h(l),p=i(l,"LI",{class:!0});var m=s(p);E(I.$$.fragment,m),m.forEach(c),f=h(l),v=i(l,"LI",{class:!0});var d=s(v);E(j.$$.fragment,d),d.forEach(c),y=h(l),g=i(l,"LI",{class:!0});var x=s(g);E(A.$$.fragment,x),x.forEach(c),$=h(l),b=i(l,"LI",{class:!0});var O=s(b);E(T.$$.fragment,O),O.forEach(c),l.forEach(c),r.forEach(c),this.h()},h(){l(a,"class","svelte-17tbtsq"),l(p,"class","svelte-17tbtsq"),l(v,"class","svelte-17tbtsq"),l(g,"class","svelte-17tbtsq"),l(b,"class","svelte-17tbtsq"),l(n,"class","links svelte-17tbtsq"),l(t,"class","svelte-17tbtsq")},m(e,r){u(e,t,r),m(t,n),m(n,a),S(w,a,null),m(n,o),m(n,p),S(I,p,null),m(n,f),m(n,v),S(j,v,null),m(n,y),m(n,g),S(A,g,null),m(n,$),m(n,b),S(T,b,null),x=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),w.$set(n);const r={};1&t&&(r.$$scope={dirty:t,ctx:e}),I.$set(r);const a={};1&t&&(a.$$scope={dirty:t,ctx:e}),j.$set(a);const i={};1&t&&(i.$$scope={dirty:t,ctx:e}),A.$set(i);const s={};1&t&&(s.$$scope={dirty:t,ctx:e}),T.$set(s)},i(e){x||(P(w.$$.fragment,e),P(I.$$.fragment,e),P(j.$$.fragment,e),P(A.$$.fragment,e),P(T.$$.fragment,e),x=!0)},o(e){k(w.$$.fragment,e),k(I.$$.fragment,e),k(j.$$.fragment,e),k(A.$$.fragment,e),k(T.$$.fragment,e),x=!1},d(e){e&&c(t),N(w),N(I),N(j),N(A),N(T)}}}class os extends e{constructor(e){super(),t(this,e,null,ss,n,{})}}var cs={internalValue:Symbol("$__value"),isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{internalValue:ls}=cs,us=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),ms=e=>e.value&&e.value[ls]?e.value[ls]:e.value,ps=(e,t)=>Object.freeze({...t,pointer:ee.append(e,t.pointer),value:t.value[e]}),fs=_((e,t)=>ms(t).map((n,r)=>e(ps(r,t),r))),ds=_((e,t)=>ms(t).map((e,n)=>ps(n,t)).filter((t,n)=>e(t,n))),hs=_((e,t,n)=>ms(n).reduce((t,r,a)=>e(t,ps(a,n),a),t)),vs=_((e,t)=>Object.keys(ms(t)).every((n,r)=>e(ps(n,t),r))),ys=_((e,t)=>Object.keys(ms(t)).some((n,r)=>e(ps(n,t),r)));var gs={cons:(e,t="")=>Object.freeze({...us,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:ms,step:ps,entries:e=>Object.keys(ms(e)).map(t=>[t,ps(t,e)]),map:fs,filter:ds,reduce:hs,every:vs,some:ys},$s=fetch;const{internalValue:bs,isObject:xs,splitUrl:ws}=cs,Is=Symbol("$__jref"),js=Symbol("$__dynamicJref"),Os={},Es={},Ss=(e,t)=>{const n=e in Es?Es[e]:e;if(n in Os)return Os[n][t]},As={},Ps={},ks=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=ws(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=Ss(r,"idToken"),i=ws(t)[0];if(!i&&!ws(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=Ms(i,e[a]||""),o=ws(s)[0];let c;i&&(Ps[i]=o),Ss(r,"vocabulary")&&xs(e)&&"$vocabulary"in e?(Es[o]=r,c=e.$vocabulary,delete e.$vocabulary):c=o===r?{[r]:!0}:{};const l={},u={};As[o]={id:o,schemaVersion:r,schema:Ns(e,o,r,ee.nil,l,u),anchors:l,recursiveAnchors:u,vocabulary:c,validated:!1}},Ns=(e,t,n,r,a,i)=>{if(xs(e)){const s=Ss(n,"idToken"),o=Ss(n,"anchorToken");if("string"==typeof e[s]){const r=e[s],a=Ms(t,r),[i,c]=ws(a);if(delete e[s],c&&s===o&&(e[o]=o!==s?encodeURI(c):`#${encodeURI(c)}`),i!==t)return ks(e,Ms(t,i),n),{[Is]:r}}const c=Ss(n,"dynamicAnchorToken");"string"==typeof e[c]&&(i[`#${e[c]}`]=t,e[o]=e[c],delete e[c]);const l=Ss(n,"recursiveAnchorToken");if(r===ee.nil&&!0===e[l]&&(i["#"]=t,delete e[l]),"string"==typeof e[o]){const t=o!==s?e[o]:e[o].slice(1);a[t]=r,delete e[o]}e=Object.entries(e).reduce((e,[s,o])=>(e[s]=Ns(o,t,n,ee.append(s,r),a,i),e),{});const u=Ss(n,"jrefToken");if("string"==typeof e[u])return e[Is]=e[u],e;const m=Ss(n,"jsrefToken");"string"==typeof e[m]&&(e[m]={[Is]:e[m],[bs]:e[m]});const p=Ss(n,"dynamicJsrefToken");return"string"==typeof e[p]&&(e[p]={[js]:e[p],[bs]:e[p]}),e}return Array.isArray(e)?e.map((e,s)=>Ns(e,t,n,ee.append(s,r),a,i)):e},Ts=e=>As[Ps[e]]||As[e],qs=Object.freeze({id:"",schemaVersion:void 0,pointer:"",schema:void 0,recursiveAnchors:{}}),Rs=async(e,t=qs,n=!1)=>{const r=n&&t.recursiveAnchors[e]?t.recursiveAnchors[e]:Ls(t),a=Ms(r,e),[i,s]=ws(a);if(!(e=>e in As||e in Ps)(i)){const e=await $s(i,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${i}`);if(e.headers.has("content-type")){const t=be.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${i} is not a schema. Found a document with media type: ${t}`)}ks(await e.json(),i)}const o=Ts(i),c=s&&"/"!==s[0]?Vs(o,s):s,l=Object.freeze({id:o.id,schemaVersion:o.schemaVersion,vocabulary:o.vocabulary,pointer:c,schema:o.schema,value:ee.get(c,o.schema),recursiveAnchors:{...o.recursiveAnchors,...t.recursiveAnchors},validated:o.validated});return Cs(l)},Cs=e=>xs(e.value)&&Is in e.value?Rs(e.value[Is],e):xs(e.value)&&js in e.value?Rs(e.value[js],e,!0):e,Ms=(e,t)=>{const n=Pe(e,t),r=ws(e)[0];if(r&&"file"===Ds(n)&&"file"!==Ds(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},Ds=e=>{const t=e.match(/^(.+):\/\//);return t?t[1]:""},Vs=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},Ls=e=>`${e.id}#${encodeURI(e.pointer)}`,Xs=e=>e.value&&e.value[bs]?e.value[bs]:e.value,Js=(e,t)=>{const n=Ts(t.id),r=Object.freeze({id:t.id,schemaVersion:t.schemaVersion,vocabulary:t.vocabulary,pointer:ee.append(e,t.pointer),schema:n.schema,value:Xs(t)[e],recursiveAnchors:t.recursiveAnchors,validated:n.validated});return Cs(r)},_s=_((e,t)=>Ae.pipeline([Xs,Ae.map(async(n,r)=>e(await Js(r,t),r)),Ae.all],t));var zs={setConfig:(e,t,n)=>{Os[e]||(Os[e]={}),Os[e][t]=n},getConfig:Ss,add:ks,get:Rs,markValidated:e=>{As[e].validated=!0},uri:Ls,value:Xs,has:(e,t)=>e in Xs(t),step:Js,entries:e=>Ae.pipeline([Xs,Object.keys,Ae.map(async t=>[t,await Js(t,e)]),Ae.all],e),map:_s};const Bs="FLAG",Fs="BASIC",Ks="DETAILED",Us="VERBOSE";let Gs=Ks,Ws=!0;const Hs=(e,t)=>(n,r=Bs)=>{if(![Bs,Fs,Ks,Us].includes(r))throw Error(`The '${r}' error format is not supported`);let a=[];const i=J.subscribe("result",Zs(r,a));return so(t,n,e),J.unsubscribe(i),a[0]},Zs=(e,t)=>{const n=[];return(r,a)=>{const i={...a,errors:[]};for(;n.length>0&&Qs(n[n.length-1],i);){const t=n.pop();let r=[];if(e===Fs&&(r=t.errors,delete t.errors),i.errors.unshift(t,...r),Ys(i))break}(e===Us||e!==Bs&&!i.valid)&&n.push(i),t[0]=i}},Qs=(e,t)=>e.instanceLocation.startsWith(t.instanceLocation)&&(e.absoluteKeywordLocation.startsWith(t.absoluteKeywordLocation)||Ys(e)),Ys=e=>e.keyword.endsWith("#$ref")||e.keyword.endsWith("#$recursiveRef"),eo={},to=e=>eo[e],no=e=>e in eo,ro={},ao={},io=async(e,t)=>{if(!no(`${e.schemaVersion}#validate`)){const t=await zs.get(e.schemaVersion);(zs.getConfig(t.id,"mandatoryVocabularies")||[]).forEach(e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)}),Object.entries(t.vocabulary).forEach(([e,n])=>{if(e in ro)Object.entries(ro[e]).forEach(([e,n])=>{((e,t)=>{eo[e]={collectEvaluatedItems:(e,n,r)=>t.interpret(e,n,r)&&0,collectEvaluatedProperties:(e,n,r)=>t.interpret(e,n,r)&&[],...t}})(`${t.id}#${e}`,n)});else if(n)throw Error(`Missing required vocabulary: ${e}`)})}if(Ws&&!e.validated){if(zs.markValidated(e.id),!(e.schemaVersion in ao)){const t=await zs.get(e.schemaVersion),n={},r=await io(t,n);ao[t.id]=Hs(n,r)}const t=gs.cons(e.schema,e.id),n=ao[e.schemaVersion](t,Gs);if(!n.valid)throw n}return await to(`${e.schemaVersion}#validate`).compile(e,t),zs.uri(e)},so=(e,t,n)=>{const[r]=n[e];return to(r).interpret(e,t,n)};var oo={validate:async(e,t,n)=>{const r={},a=await io(e,r),i=(e,t=Bs)=>Hs(r,a)(gs.cons(e),t);return void 0===t?i:i(t,n)},setMetaOutputFormat:e=>{Gs=e},setShouldMetaValidate:e=>{Ws=e},FLAG:Bs,BASIC:Fs,DETAILED:Ks,VERBOSE:Us,getKeyword:to,hasKeyword:no,defineVocabulary:(e,t)=>{ro[e]=t},compileSchema:io,interpretSchema:so,collectEvaluatedProperties:(e,t,n,r)=>{const[a]=n[e];return to(a).collectEvaluatedProperties(e,t,n,r)},collectEvaluatedItems:(e,t,n,r)=>{const[a]=n[e];return to(a).collectEvaluatedItems(e,t,n,r)}};var co={compile:async(e,t)=>{const n=zs.uri(e);if(!(n in t)){t[n]=!1;const r=zs.value(e);t[n]=[`${e.schemaVersion}#validate`,zs.uri(e),"boolean"==typeof r?r:await Ae.pipeline([zs.entries,Ae.map(([t,n])=>[`${e.schemaVersion}#${t}`,n]),Ae.filter(([t])=>oo.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`),Ae.map(async([n,r])=>{const a=await oo.getKeyword(n).compile(r,t,e);return[n,zs.uri(r),a]}),Ae.all],e)]}},interpret:(e,t,n)=>{const[r,a,i]=n[e],s="boolean"==typeof i?i:i.every(([e,r,a])=>{const i=oo.getKeyword(e).interpret(a,t,n);return J.publishSync("result",{keyword:e,absoluteKeywordLocation:r,instanceLocation:gs.uri(t),valid:i}),i});return J.publishSync("result",{keyword:r,absoluteKeywordLocation:a,instanceLocation:gs.uri(t),valid:s}),s},collectEvaluatedProperties:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter(([e])=>!r||!e.endsWith("#unevaluatedProperties")).reduce((e,[r,,a])=>{const i=e&&oo.getKeyword(r).collectEvaluatedProperties(a,t,n);return i&&e.concat(i)},[])},collectEvaluatedItems:(e,t,n,r=!1)=>{const a=n[e][2];return"boolean"==typeof a?!!a&&[]:a.filter(([e])=>!r||!e.endsWith("#unevaluatedItems")).reduce((e,[r,,a])=>{const i=!1!==e&&oo.getKeyword(r).collectEvaluatedItems(a,t,n);return!1!==i&&Math.max(e,i)},0)}},lo={Core:oo,Schema:zs,Instance:gs,Keywords:{metaData:{compile:()=>void 0,interpret:()=>!0},validate:co}},uo=lo.Core,mo=lo.Schema;const po="https://json-schema.org/draft/2020-XX/schema";function fo(e){return{c:p,l:p,m:p,p:p,i:p,o:p,d:p}}function ho(e){let t;const n=new Fi({props:{results:e[4]}});return{c(){O(n.$$.fragment)},l(e){E(n.$$.fragment,e)},m(e,r){S(n,e,r),t=!0},p(e,t){const r={};16&t&&(r.results=e[4]),n.$set(r)},i(e){t||(P(n.$$.fragment,e),t=!0)},o(e){k(n.$$.fragment,e),t=!1},d(e){N(n,e)}}}function vo(e){return{c:p,l:p,m:p,p:p,i:p,o:p,d:p}}function yo(e){let t,n,p,f,v,y,g,$,b,x,w,T,R,C,M,D,L,X,J;const _=new Ri({props:{tabs:e[0],newTab:e[5],active:0}});function z(t){e[10].call(null,t)}function B(t){e[11].call(null,t)}_.$on("input",e[7]);let F={tabs:e[1],newTab:e[6]};void 0!==e[2]&&(F.selected=e[2]),void 0!==e[2]&&(F.active=e[2]);const K=new Ri({props:F});I.push(()=>j(K,"selected",z)),I.push(()=>j(K,"active",B)),K.$on("input",e[8]);const U=new Fi({props:{results:e[3]}});let G={ctx:e,current:null,token:null,pending:vo,then:ho,catch:fo,value:12,blocks:[,,,]};q(D=e[3],G);const W=new os({});return{c(){t=d(),n=r("main"),p=r("h1"),f=a("Hyperjump - JSON Schema Validator"),v=d(),y=r("div"),O(_.$$.fragment),g=d(),$=r("div"),O(K.$$.fragment),w=d(),T=r("div"),O(U.$$.fragment),C=d(),M=r("div"),G.block.c(),X=d(),O(W.$$.fragment),this.h()},l(e){V('[data-svelte="svelte-14138tz"]',document.head).forEach(c),t=h(e),n=i(e,"MAIN",{class:!0});var r=s(n);p=i(r,"H1",{class:!0});var a=s(p);f=o(a,"Hyperjump - JSON Schema Validator"),a.forEach(c),v=h(r),y=i(r,"DIV",{class:!0});var l=s(y);E(_.$$.fragment,l),l.forEach(c),g=h(r),$=i(r,"DIV",{class:!0});var u=s($);E(K.$$.fragment,u),u.forEach(c),w=h(r),T=i(r,"DIV",{class:!0});var m=s(T);E(U.$$.fragment,m),m.forEach(c),C=h(r),M=i(r,"DIV",{class:!0});var d=s(M);G.block.l(d),d.forEach(c),X=h(r),E(W.$$.fragment,r),r.forEach(c),this.h()},h(){document.title="Hyperjump - JSON Schema Validator",l(p,"class","svelte-1fbysc"),l(y,"class","editor-section svelte-1fbysc"),l($,"class","editor-section svelte-1fbysc"),l(T,"class",R="results "+xo+" svelte-1fbysc"),l(M,"class",L="results "+xo+" svelte-1fbysc"),l(n,"class","svelte-1fbysc")},m(e,r){u(e,t,r),u(e,n,r),m(n,p),m(p,f),m(n,v),m(n,y),S(_,y,null),m(n,g),m(n,$),S(K,$,null),m(n,w),m(n,T),S(U,T,null),m(n,C),m(n,M),G.block.m(M,G.anchor=null),G.mount=(()=>M),G.anchor=null,m(n,X),S(W,n,null),J=!0},p(t,[n]){e=t;const r={};1&n&&(r.tabs=e[0]),_.$set(r);const a={};2&n&&(a.tabs=e[1]),!b&&4&n&&(b=!0,a.selected=e[2],A(()=>b=!1)),!x&&4&n&&(x=!0,a.active=e[2],A(()=>x=!1)),K.$set(a);const i={};if(8&n&&(i.results=e[3]),U.$set(i),G.ctx=e,8&n&&D!==(D=e[3])&&q(D,G));else{const t=e.slice();t[12]=G.resolved,G.block.p(t,n)}},i(e){J||(P(_.$$.fragment,e),P(K.$$.fragment,e),P(U.$$.fragment,e),P(G.block),P(W.$$.fragment,e),J=!0)},o(e){k(_.$$.fragment,e),k(K.$$.fragment,e),k(U.$$.fragment,e);for(let e=0;e<3;e+=1){const t=G.blocks[e];k(t)}k(W.$$.fragment,e),J=!1},d(e){e&&c(t),e&&c(n),N(_),N(K),N(U),G.block.d(),G.token=null,G=null,N(W)}}}mo.setConfig(po,"idToken","$id"),mo.setConfig(po,"anchorToken","$anchor"),mo.setConfig(po,"jsrefToken","$ref"),mo.setConfig(po,"dynamicJsrefToken","$recursiveRef"),mo.setConfig(po,"dynamicAnchorToken","$dynamcicAnchor"),mo.setConfig(po,"commentToken","$comment"),mo.setConfig(po,"vocabulary",!0),mo.setConfig(po,"mandatoryVocabularies",["https://json-schema.org/draft/2020-XX/vocab/core"]),mo.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$id": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-XX/vocab/core": true,\n        "https://json-schema.org/draft/2020-XX/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-XX/vocab/validation": true,\n        "https://json-schema.org/draft/2020-XX/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-XX/vocab/format": false,\n        "https://json-schema.org/draft/2020-XX/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),mo.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "const": true,\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),uo.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/core",{validate:Fa.validate,$comment:Fa.metaData,$defs:Fa.definitions,$recursiveRef:Fa.$recursiveRef,$ref:Fa.$ref}),mo.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),uo.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/applicator",{additionalItems:Fa.additionalItems6,additionalProperties:Fa.additionalProperties6,allOf:Fa.allOf,anyOf:Fa.anyOf,contains:Fa.containsMinContainsMaxContains,dependentSchemas:Fa.dependentSchemas,if:Fa.ifThenElse,items:Fa.items,not:Fa.not,oneOf:Fa.oneOf,patternProperties:Fa.patternProperties,properties:Fa.properties,propertyNames:Fa.propertyNames,unevaluatedItems:Fa.unevaluatedItems,unevaluatedProperties:Fa.unevaluatedProperties}),mo.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": ["number", "boolean"]\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": ["number", "boolean"]\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "allOf": [\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMinimum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMinimum"]\n            },\n            "then": {\n                "required": ["minimum"]\n            }\n        },\n        {\n            "if": {\n                "properties": {\n                    "exclusiveMaximum": { "type": "boolean" }\n                },\n                "required": ["exclusiveMaximum"]\n            },\n            "then": {\n                "required": ["maximum"]\n            }\n        }\n    ],\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),uo.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/validation",{const:Fa.const,dependentRequired:Fa.dependentRequired,enum:Fa.enum,exclusiveMaximum:Fa.exclusiveMaximum,exclusiveMinimum:Fa.exclusiveMinimum,maxItems:Fa.maxItems,maxLength:Fa.maxLength6,maxProperties:Fa.maxProperties,maximum:Fa.maximum,minItems:Fa.minItems,minLength:Fa.minLength6,minProperties:Fa.minProperties,minimum:Fa.minimum,multipleOf:Fa.multipleOf,pattern:Fa.pattern,required:Fa.required,type:Fa.type,uniqueItems:Fa.uniqueItems}),mo.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),uo.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/meta-data",{default:Fa.metaData,deprecated:Fa.metaData,description:Fa.metaData,examples:Fa.metaData,readOnly:Fa.metaData,title:Fa.metaData,writeOnly:Fa.metaData}),mo.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/format",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),mo.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-XX/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-XX/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2020-XX/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),uo.defineVocabulary("https://json-schema.org/draft/2020-XX/vocab/content",{contentEncoding:Fa.metaData,contentMediaType:Fa.metaData,contentSchema:Fa.metaData});const go=750,$o="https://json-schema.org/draft/2019-09/schema",bo="https://json-schema.hyperjump.io/schema",xo="solarized-dark";function wo(e,t,n){const r=function(){let e=1;return(t,n,r=!1)=>{const a=n||`${bo}${++e}`;return{label:t||`Schema ${e}`,text:`{\n  "$id": "${a}",\n  "$schema": "${$o}"\n}`,persistent:r}}}(),a=function(){let e=1;return()=>({label:`Instance ${e++}`,text:""})}();let i=[r("Schema",bo,!0)],s=[a("Instance")],o=0;const c=function(e,t){let n;return({detail:r})=>{clearTimeout(n),n=setTimeout(()=>e(r),t)}},l=c(e=>n(0,i=e),go),u=c(e=>n(1,s=e),go);let m,p;return li.setMetaOutputFormat(li.BASIC),e.$$.update=(()=>{1&e.$$.dirty&&n(3,m=async function(){i.forEach((e,t)=>{const n=0===t?bo:"";li.add(JSON.parse(e.text||"true"),n,$o)});const e=await li.get(bo);return li.validate(e)}()),14&e.$$.dirty&&n(4,p=async function(){if(""!==s[o].text){let e;try{e=await m}catch(e){}if(e){const t=e(JSON.parse(s[o].text),li.BASIC);if(t.valid)return t;throw t}}}())}),[i,s,o,m,p,r,a,l,u,c,function(e){n(2,o=e)},function(e){n(2,o=e)}]}export default class extends e{constructor(e){super(),t(this,e,wo,yo,n,{})}}
